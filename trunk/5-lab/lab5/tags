!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.8	//
ALT	kern/console.c	216;"	d	file:
AR	GNUmakefile	/^AR	:= $(GCCPREFIX)ar$/;"	m
ARGBEGIN	inc/args.h	79;"	d
ARGC	inc/args.h	98;"	d
ARGEND	inc/args.h	92;"	d
ARGF	inc/args.h	93;"	d
AS	GNUmakefile	/^AS	:= $(GCCPREFIX)as$/;"	m
BLKBITSIZE	inc/fs.h	12;"	d
BLKFILES	inc/fs.h	49;"	d
BLKSECTS	fs/fs.h	5;"	d
BLKSIZE	inc/fs.h	11;"	d
BLOCK_BITS	fs/fsformat.c	/^	BLOCK_BITS$/;"	e	enum:__anon4	file:
BLOCK_DIR	fs/fsformat.c	/^	BLOCK_DIR,$/;"	e	enum:__anon4	file:
BLOCK_FILE	fs/fsformat.c	/^	BLOCK_FILE,$/;"	e	enum:__anon4	file:
BLOCK_SUPER	fs/fsformat.c	/^	BLOCK_SUPER,$/;"	e	enum:__anon4	file:
BUFLEN	lib/readline.c	4;"	d	file:
Block	fs/fsformat.c	/^struct Block$/;"	s	file:
C	kern/console.c	283;"	d	file:
CAPSLOCK	kern/console.c	218;"	d	file:
CC	GNUmakefile	/^CC	:= $(GCCPREFIX)gcc -pipe$/;"	m
CFLAGS	GNUmakefile	/^CFLAGS := $(CFLAGS) $(DEFS) $(LABDEFS) -O1 -fno-builtin -I$(TOP) -MD $/;"	m
CGA_BASE	kern/console.h	13;"	d
CGA_BUF	kern/console.h	14;"	d
CHECKSUM	kern/entry.S	/^#define CHECKSUM (-(MULTIBOOT_HEADER_MAGIC + MULTIBOOT_HEADER_FLAGS))$/;"	d
CMDBUF_SIZE	kern/monitor.c	16;"	d	file:
CMDBYTE	inc/kbdreg.h	60;"	d
COM1	kern/console.c	18;"	d	file:
COM_DLL	kern/console.c	21;"	d	file:
COM_DLM	kern/console.c	22;"	d	file:
COM_FCR	kern/console.c	26;"	d	file:
COM_IER	kern/console.c	23;"	d	file:
COM_IER_RDI	kern/console.c	24;"	d	file:
COM_IIR	kern/console.c	25;"	d	file:
COM_LCR	kern/console.c	27;"	d	file:
COM_LCR_DLAB	kern/console.c	28;"	d	file:
COM_LCR_WLEN8	kern/console.c	29;"	d	file:
COM_LSR	kern/console.c	34;"	d	file:
COM_LSR_DATA	kern/console.c	35;"	d	file:
COM_MCR	kern/console.c	30;"	d	file:
COM_MCR_DTR	kern/console.c	32;"	d	file:
COM_MCR_OUT2	kern/console.c	33;"	d	file:
COM_MCR_RTS	kern/console.c	31;"	d	file:
COM_RX	kern/console.c	20;"	d	file:
CONSBUFSIZE	kern/console.c	382;"	d	file:
CR0_AM	inc/mmu.h	88;"	d
CR0_CD	inc/mmu.h	90;"	d
CR0_EM	inc/mmu.h	83;"	d
CR0_ET	inc/mmu.h	85;"	d
CR0_MP	inc/mmu.h	82;"	d
CR0_NE	inc/mmu.h	86;"	d
CR0_NW	inc/mmu.h	89;"	d
CR0_PE	inc/mmu.h	81;"	d
CR0_PG	inc/mmu.h	91;"	d
CR0_TS	inc/mmu.h	84;"	d
CR0_WP	inc/mmu.h	87;"	d
CR4_DE	inc/mmu.h	96;"	d
CR4_MCE	inc/mmu.h	94;"	d
CR4_PCE	inc/mmu.h	93;"	d
CR4_PSE	inc/mmu.h	95;"	d
CR4_PVI	inc/mmu.h	98;"	d
CR4_TSD	inc/mmu.h	97;"	d
CR4_VME	inc/mmu.h	99;"	d
CRT_COLS	kern/console.h	17;"	d
CRT_ROWS	kern/console.h	16;"	d
CRT_SIZE	kern/console.h	18;"	d
CTL	kern/console.c	215;"	d	file:
Command	kern/monitor.c	/^struct Command {$/;"	s	file:
DEPTH	user/forktree.c	5;"	d	file:
DISKMAP	fs/fs.h	9;"	d
DISKSIZE	fs/fs.h	12;"	d
Dev	inc/fd.h	/^struct Dev {$/;"	s
E0ESC	kern/console.c	222;"	d	file:
EARGF	inc/args.h	95;"	d
ELFHDR	boot/main.c	33;"	d	file:
ELF_MAGIC	inc/elf.h	4;"	d
ELF_PROG_FLAG_EXEC	inc/elf.h	52;"	d
ELF_PROG_FLAG_READ	inc/elf.h	54;"	d
ELF_PROG_FLAG_WRITE	inc/elf.h	53;"	d
ELF_PROG_LOAD	inc/elf.h	49;"	d
ELF_SHN_UNDEF	inc/elf.h	63;"	d
ELF_SHT_NULL	inc/elf.h	57;"	d
ELF_SHT_PROGBITS	inc/elf.h	58;"	d
ELF_SHT_STRTAB	inc/elf.h	60;"	d
ELF_SHT_SYMTAB	inc/elf.h	59;"	d
ENVGENSHIFT	kern/env.c	20;"	d	file:
ENVX	inc/env.h	31;"	d
ENV_CREATE	kern/env.h	36;"	d
ENV_CREATE2	kern/env.h	31;"	d
ENV_FREE	inc/env.h	34;"	d
ENV_NOT_RUNNABLE	inc/env.h	36;"	d
ENV_PRIO_HIGHEST	inc/env.h	38;"	d
ENV_PRIO_LOWEST	inc/env.h	39;"	d
ENV_RUNNABLE	inc/env.h	35;"	d
EXTPHYSMEM	inc/memlayout.h	88;"	d
E_BAD_ENV	inc/error.h	8;"	d
E_BAD_PATH	inc/error.h	23;"	d
E_EOF	inc/error.h	17;"	d
E_FAULT	inc/error.h	14;"	d
E_FILE_EXISTS	inc/error.h	24;"	d
E_INVAL	inc/error.h	10;"	d
E_IPC_NOT_RECV	inc/error.h	16;"	d
E_MAX_OPEN	inc/error.h	21;"	d
E_NOT_EXEC	inc/error.h	25;"	d
E_NOT_FOUND	inc/error.h	22;"	d
E_NO_DISK	inc/error.h	20;"	d
E_NO_FREE_ENV	inc/error.h	12;"	d
E_NO_MEM	inc/error.h	11;"	d
E_UNSPECIFIED	inc/error.h	7;"	d
Eipdebuginfo	kern/kdebug.h	/^struct Eipdebuginfo {$/;"	s
Elf	inc/elf.h	/^struct Elf {$/;"	s
Env	inc/env.h	/^struct Env {$/;"	s
FDTABLE	lib/fd.c	10;"	d	file:
FEC_PR	inc/mmu.h	125;"	d
FEC_U	inc/mmu.h	127;"	d
FEC_WR	inc/mmu.h	126;"	d
FILEBASE	lib/fd.c	8;"	d	file:
FILEVA	fs/serv.c	23;"	d	file:
FL_AC	inc/mmu.h	119;"	d
FL_AF	inc/mmu.h	104;"	d
FL_CF	inc/mmu.h	102;"	d
FL_DF	inc/mmu.h	109;"	d
FL_ID	inc/mmu.h	122;"	d
FL_IF	inc/mmu.h	108;"	d
FL_IOPL_0	inc/mmu.h	112;"	d
FL_IOPL_1	inc/mmu.h	113;"	d
FL_IOPL_2	inc/mmu.h	114;"	d
FL_IOPL_3	inc/mmu.h	115;"	d
FL_IOPL_MASK	inc/mmu.h	111;"	d
FL_NT	inc/mmu.h	116;"	d
FL_OF	inc/mmu.h	110;"	d
FL_PF	inc/mmu.h	103;"	d
FL_RF	inc/mmu.h	117;"	d
FL_SF	inc/mmu.h	106;"	d
FL_TF	inc/mmu.h	107;"	d
FL_VIF	inc/mmu.h	120;"	d
FL_VIP	inc/mmu.h	121;"	d
FL_VM	inc/mmu.h	118;"	d
FL_ZF	inc/mmu.h	105;"	d
FSREQ_CLOSE	inc/fs.h	71;"	d
FSREQ_DIRTY	inc/fs.h	72;"	d
FSREQ_MAP	inc/fs.h	69;"	d
FSREQ_OPEN	inc/fs.h	68;"	d
FSREQ_REMOVE	inc/fs.h	73;"	d
FSREQ_SET_SIZE	inc/fs.h	70;"	d
FSREQ_SYNC	inc/fs.h	74;"	d
FS_MAGIC	inc/fs.h	58;"	d
FTYPE_DIR	inc/fs.h	53;"	d
FTYPE_REG	inc/fs.h	52;"	d
FVA	user/testfsipc.c	14;"	d	file:
Fd	inc/fd.h	/^struct Fd {$/;"	s
FdFile	inc/fd.h	/^struct FdFile {$/;"	s
File	fs/fsformat.c	/^typedef struct File File;$/;"	t	typeref:struct:File	file:
File	inc/fs.h	/^struct File {$/;"	s
Fsreq_close	inc/fs.h	/^struct Fsreq_close {$/;"	s
Fsreq_dirty	inc/fs.h	/^struct Fsreq_dirty {$/;"	s
Fsreq_map	inc/fs.h	/^struct Fsreq_map {$/;"	s
Fsreq_open	inc/fs.h	/^struct Fsreq_open {$/;"	s
Fsreq_remove	inc/fs.h	/^struct Fsreq_remove {$/;"	s
Fsreq_set_size	inc/fs.h	/^struct Fsreq_set_size {$/;"	s
GCCPREFIX	GNUmakefile	/^GCCPREFIX := $(shell if i386-jos-elf-objdump -i 2>&1 | grep '^elf32-i386$$' >\/dev\/null 2>&1; \\$/;"	m
GCC_LIB	GNUmakefile	/^GCC_LIB := $(shell $(CC) $(CFLAGS) -print-libgcc-file-name)$/;"	m
GD_KD	inc/memlayout.h	17;"	d
GD_KT	inc/memlayout.h	16;"	d
GD_TSS	inc/memlayout.h	20;"	d
GD_UD	inc/memlayout.h	19;"	d
GD_UT	inc/memlayout.h	18;"	d
Gatedesc	inc/mmu.h	/^struct Gatedesc {$/;"	s
IDE_BSY	fs/ide.c	10;"	d	file:
IDE_DF	fs/ide.c	12;"	d	file:
IDE_DRDY	fs/ide.c	11;"	d	file:
IDE_ERR	fs/ide.c	13;"	d	file:
IMAGES	GNUmakefile	/^IMAGES = $(OBJDIR)\/kern\/bochs.img $(OBJDIR)\/fs\/fs.img$/;"	m
INDEX2DATA	lib/fd.c	15;"	d	file:
INDEX2FD	lib/fd.c	13;"	d	file:
IOM_BEGIN	inc/isareg.h	125;"	d
IOM_END	inc/isareg.h	126;"	d
IOM_SIZE	inc/isareg.h	127;"	d
IOPHYSMEM	inc/memlayout.h	87;"	d
IO_AHA0	inc/isareg.h	63;"	d
IO_AHA1	inc/isareg.h	66;"	d
IO_BMS1	inc/isareg.h	46;"	d
IO_BMS2	inc/isareg.h	45;"	d
IO_BT0	inc/isareg.h	62;"	d
IO_BT1	inc/isareg.h	65;"	d
IO_CGA	inc/isareg.h	82;"	d
IO_CGASIZE	inc/isareg.h	103;"	d
IO_COM1	inc/isareg.h	88;"	d
IO_COM2	inc/isareg.h	58;"	d
IO_COM3	inc/isareg.h	86;"	d
IO_COM4	inc/isareg.h	54;"	d
IO_COMSIZE	inc/isareg.h	102;"	d
IO_DMA1	inc/isareg.h	18;"	d
IO_DMA2	inc/isareg.h	29;"	d
IO_DMAPG	inc/isareg.h	27;"	d
IO_DMASIZE	inc/isareg.h	104;"	d
IO_DPGSIZE	inc/isareg.h	105;"	d
IO_FD1	inc/isareg.h	87;"	d
IO_FD2	inc/isareg.h	74;"	d
IO_FDCSIZE	inc/isareg.h	106;"	d
IO_GAME	inc/isareg.h	41;"	d
IO_GAMSIZE	inc/isareg.h	108;"	d
IO_ICU1	inc/isareg.h	19;"	d
IO_ICU2	inc/isareg.h	28;"	d
IO_ICUSIZE	inc/isareg.h	109;"	d
IO_ISABEGIN	inc/isareg.h	15;"	d
IO_ISAEND	inc/isareg.h	90;"	d
IO_ISASIZES	inc/isareg.h	100;"	d
IO_KBD	inc/isareg.h	23;"	d
IO_KBDSIZE	inc/isareg.h	110;"	d
IO_LPT1	inc/isareg.h	75;"	d
IO_LPT2	inc/isareg.h	50;"	d
IO_LPT3	inc/isareg.h	80;"	d
IO_LPTSIZE	inc/isareg.h	111;"	d
IO_MDA	inc/isareg.h	79;"	d
IO_MDASIZE	inc/isareg.h	112;"	d
IO_NMI	inc/isareg.h	26;"	d
IO_NPX	inc/isareg.h	30;"	d
IO_NPXSIZE	inc/isareg.h	115;"	d
IO_PIC1	kern/picirq.h	12;"	d
IO_PIC2	kern/picirq.h	13;"	d
IO_PMP1	inc/isareg.h	20;"	d
IO_PMP2	inc/isareg.h	36;"	d
IO_PMPSIZE	inc/isareg.h	117;"	d
IO_PPI	inc/isareg.h	24;"	d
IO_RTC	inc/isareg.h	25;"	d
IO_RTC	kern/kclock.h	9;"	d
IO_RTCSIZE	inc/isareg.h	113;"	d
IO_TIMER1	inc/isareg.h	21;"	d
IO_TIMER2	inc/isareg.h	22;"	d
IO_TMRSIZE	inc/isareg.h	114;"	d
IO_UHA0	inc/isareg.h	64;"	d
IO_VGA	inc/isareg.h	81;"	d
IO_VGASIZE	inc/isareg.h	116;"	d
IO_WD1	inc/isareg.h	40;"	d
IO_WD2	inc/isareg.h	35;"	d
IO_WDCSIZE	inc/isareg.h	107;"	d
IO_WDS	inc/isareg.h	70;"	d
IRQ_ERROR	inc/trap.h	36;"	d
IRQ_IDE	inc/trap.h	35;"	d
IRQ_KBD	inc/trap.h	34;"	d
IRQ_OFFSET	kern/picirq.h	16;"	d
IRQ_SLAVE	kern/picirq.h	15;"	d
IRQ_SPURIOUS	inc/trap.h	37;"	d
IRQ_TIMER	inc/trap.h	33;"	d
JOS_INC_ASSERT_H	inc/assert.h	4;"	d
JOS_INC_ELF_H	inc/elf.h	2;"	d
JOS_INC_ENV_H	inc/env.h	4;"	d
JOS_INC_ERROR_H	inc/error.h	4;"	d
JOS_INC_FD_H	inc/fd.h	6;"	d
JOS_INC_FS_H	inc/fs.h	4;"	d
JOS_INC_LIB_H	inc/lib.h	8;"	d
JOS_INC_MALLOC_H	inc/malloc.h	2;"	d
JOS_INC_MEMLAYOUT_H	inc/memlayout.h	2;"	d
JOS_INC_MMU_H	inc/mmu.h	2;"	d
JOS_INC_QUEUE_H	inc/queue.h	36;"	d
JOS_INC_STDARG_H	inc/stdarg.h	4;"	d
JOS_INC_STDIO_H	inc/stdio.h	2;"	d
JOS_INC_STRING_H	inc/string.h	2;"	d
JOS_INC_SYSCALL_H	inc/syscall.h	2;"	d
JOS_INC_TRAP_H	inc/trap.h	2;"	d
JOS_INC_TYPES_H	fs/fsformat.c	27;"	d	file:
JOS_INC_TYPES_H	inc/types.h	2;"	d
JOS_INC_X86_H	inc/x86.h	2;"	d
JOS_KBDREG_H	inc/kbdreg.h	2;"	d
JOS_KERN_ENV_H	kern/env.h	4;"	d
JOS_KERN_KCLOCK_H	kern/kclock.h	4;"	d
JOS_KERN_KDEBUG_H	kern/kdebug.h	2;"	d
JOS_KERN_MONITOR_H	kern/monitor.h	2;"	d
JOS_KERN_PICIRQ_H	kern/picirq.h	4;"	d
JOS_KERN_PMAP_H	kern/pmap.h	4;"	d
JOS_KERN_SCHED_H	kern/sched.h	4;"	d
JOS_KERN_SYSCALL_H	kern/syscall.h	2;"	d
JOS_KERN_TRAP_H	kern/trap.h	4;"	d
JOS_MULTIENV	kern/env.h	11;"	d
JOS_STAB_H	inc/stab.h	2;"	d
KADDR	kern/pmap.h	29;"	d
KBCMDP	inc/kbdreg.h	29;"	d
KBC_AUXDISABLE	inc/kbdreg.h	32;"	d
KBC_AUXECHO	inc/kbdreg.h	36;"	d
KBC_AUXENABLE	inc/kbdreg.h	33;"	d
KBC_AUXTEST	inc/kbdreg.h	34;"	d
KBC_AUXWRITE	inc/kbdreg.h	37;"	d
KBC_DISABLE	inc/kbdreg.h	66;"	d
KBC_ECHO	inc/kbdreg.h	71;"	d
KBC_ENABLE	inc/kbdreg.h	67;"	d
KBC_KBDDISABLE	inc/kbdreg.h	40;"	d
KBC_KBDECHO	inc/kbdreg.h	35;"	d
KBC_KBDENABLE	inc/kbdreg.h	41;"	d
KBC_KBDTEST	inc/kbdreg.h	39;"	d
KBC_MODEIND	inc/kbdreg.h	70;"	d
KBC_PULSE0	inc/kbdreg.h	42;"	d
KBC_PULSE1	inc/kbdreg.h	43;"	d
KBC_PULSE2	inc/kbdreg.h	44;"	d
KBC_PULSE3	inc/kbdreg.h	45;"	d
KBC_RAMREAD	inc/kbdreg.h	30;"	d
KBC_RAMWRITE	inc/kbdreg.h	31;"	d
KBC_RESEND	inc/kbdreg.h	64;"	d
KBC_RESET	inc/kbdreg.h	63;"	d
KBC_SELFTEST	inc/kbdreg.h	38;"	d
KBC_SETDEFAULT	inc/kbdreg.h	65;"	d
KBC_SETTABLE	inc/kbdreg.h	69;"	d
KBC_TYPEMATIC	inc/kbdreg.h	68;"	d
KBDATAP	inc/kbdreg.h	47;"	d
KBOUTP	inc/kbdreg.h	48;"	d
KBR_ACK	inc/kbdreg.h	76;"	d
KBR_BREAK	inc/kbdreg.h	79;"	d
KBR_ECHO	inc/kbdreg.h	81;"	d
KBR_EXTENDED	inc/kbdreg.h	74;"	d
KBR_FAILURE	inc/kbdreg.h	78;"	d
KBR_OVERRUN	inc/kbdreg.h	77;"	d
KBR_RESEND	inc/kbdreg.h	75;"	d
KBR_RSTDONE	inc/kbdreg.h	80;"	d
KBSTATP	inc/kbdreg.h	19;"	d
KBS_DIB	inc/kbdreg.h	20;"	d
KBS_IBF	inc/kbdreg.h	21;"	d
KBS_NOSEC	inc/kbdreg.h	24;"	d
KBS_OCMD	inc/kbdreg.h	23;"	d
KBS_PERR	inc/kbdreg.h	27;"	d
KBS_RERR	inc/kbdreg.h	26;"	d
KBS_TERR	inc/kbdreg.h	25;"	d
KBS_WARM	inc/kbdreg.h	22;"	d
KC8_CPU	inc/kbdreg.h	57;"	d
KC8_IGNSEC	inc/kbdreg.h	56;"	d
KC8_KDISABLE	inc/kbdreg.h	55;"	d
KC8_KENABLE	inc/kbdreg.h	59;"	d
KC8_MDISABLE	inc/kbdreg.h	54;"	d
KC8_MENABLE	inc/kbdreg.h	58;"	d
KC8_TRANS	inc/kbdreg.h	53;"	d
KERNBASE	inc/memlayout.h	82;"	d
KERN_CFLAGS	GNUmakefile	/^KERN_CFLAGS := $(CFLAGS) -DJOS_KERNEL -gstabs$/;"	m
KEY_DEL	inc/kbdreg.h	14;"	d
KEY_DN	inc/kbdreg.h	8;"	d
KEY_END	inc/kbdreg.h	6;"	d
KEY_HOME	inc/kbdreg.h	5;"	d
KEY_INS	inc/kbdreg.h	13;"	d
KEY_LF	inc/kbdreg.h	9;"	d
KEY_PGDN	inc/kbdreg.h	12;"	d
KEY_PGUP	inc/kbdreg.h	11;"	d
KEY_RT	inc/kbdreg.h	10;"	d
KEY_UP	inc/kbdreg.h	7;"	d
KSTACKTOP	inc/memlayout.h	95;"	d
KSTKSIZE	inc/memlayout.h	96;"	d
K_LDCMDBYTE	inc/kbdreg.h	51;"	d
K_RDCMDBYTE	inc/kbdreg.h	50;"	d
LAB	conf/lab.mk	/^LAB=5$/;"	m
LABADJUST	GNUmakefile	/^LABADJUST := 0$/;"	m
LABSETUP	GNUmakefile	/^LABSETUP := .\/$/;"	m
LD	GNUmakefile	/^LD	:= $(GCCPREFIX)ld$/;"	m
LDFLAGS	GNUmakefile	/^LDFLAGS := -m elf_i386$/;"	m
LIST_EMPTY	inc/queue.h	142;"	d
LIST_ENTRY	inc/queue.h	129;"	d
LIST_FIRST	inc/queue.h	147;"	d
LIST_FOREACH	inc/queue.h	160;"	d
LIST_HEAD	inc/queue.h	109;"	d
LIST_HEAD_INITIALIZER	inc/queue.h	118;"	d
LIST_INIT	inc/queue.h	168;"	d
LIST_INSERT_AFTER	inc/queue.h	177;"	d
LIST_INSERT_BEFORE	inc/queue.h	190;"	d
LIST_INSERT_HEAD	inc/queue.h	201;"	d
LIST_NEXT	inc/queue.h	153;"	d
LIST_REMOVE	inc/queue.h	212;"	d
LOG2NENV	inc/env.h	29;"	d
MAX	inc/types.h	48;"	d
MAXARGS	kern/monitor.c	300;"	d	file:
MAXERROR	inc/error.h	27;"	d
MAXFD	lib/fd.c	6;"	d	file:
MAXFILESIZE	inc/fs.h	26;"	d
MAXNAMELEN	inc/fs.h	16;"	d
MAXOPEN	fs/serv.c	22;"	d	file:
MAXPATHLEN	inc/fs.h	19;"	d
MAX_IRQS	kern/picirq.h	9;"	d
MC_NVRAM_SIZE	kern/kclock.h	12;"	d
MC_NVRAM_START	kern/kclock.h	11;"	d
MIN	inc/types.h	42;"	d
MONO_BASE	kern/console.h	11;"	d
MONO_BUF	kern/console.h	12;"	d
MULTIBOOT_HEADER_FLAGS	kern/entry.S	/^#define MULTIBOOT_HEADER_FLAGS (MULTIBOOT_MEMORY_INFO | MULTIBOOT_PAGE_ALIGN)$/;"	d
MULTIBOOT_HEADER_MAGIC	kern/entry.S	/^#define MULTIBOOT_HEADER_MAGIC (0x1BADB002)$/;"	d
MULTIBOOT_MEMORY_INFO	kern/entry.S	/^#define MULTIBOOT_MEMORY_INFO (1<<1)$/;"	d
MULTIBOOT_PAGE_ALIGN	kern/entry.S	/^#define MULTIBOOT_PAGE_ALIGN  (1<<0)$/;"	d
NCC	GNUmakefile	/^NCC	:= gcc $(CC_VER) -pipe$/;"	m
NCOMMANDS	kern/monitor.c	47;"	d	file:
NDIRECT	inc/fs.h	22;"	d
NENV	inc/env.h	30;"	d
NINDIRECT	inc/fs.h	24;"	d
NM	GNUmakefile	/^NM	:= $(GCCPREFIX)nm$/;"	m
NO	kern/console.c	212;"	d	file:
NPDENTRIES	inc/mmu.h	47;"	d
NPTENTRIES	inc/mmu.h	48;"	d
NSYSCALLS	inc/syscall.h	/^	NSYSCALLS$/;"	e	enum:__anon3
NULL	inc/stdio.h	7;"	d
NULL	inc/types.h	5;"	d
NUMLOCK	kern/console.c	219;"	d	file:
NVRAM_BASEHI	kern/kclock.h	16;"	d
NVRAM_BASELO	kern/kclock.h	15;"	d
NVRAM_CENTURY	kern/kclock.h	27;"	d
NVRAM_EXTHI	kern/kclock.h	20;"	d
NVRAM_EXTLO	kern/kclock.h	19;"	d
NVRAM_PEXTHI	kern/kclock.h	24;"	d
NVRAM_PEXTLO	kern/kclock.h	23;"	d
N_BCOMM	inc/stab.h	37;"	d
N_BINCL	inc/stab.h	29;"	d
N_BSLINE	inc/stab.h	25;"	d
N_DSLINE	inc/stab.h	24;"	d
N_ECOML	inc/stab.h	39;"	d
N_ECOMM	inc/stab.h	38;"	d
N_EINCL	inc/stab.h	32;"	d
N_ENTRY	inc/stab.h	33;"	d
N_EXCL	inc/stab.h	35;"	d
N_FNAME	inc/stab.h	16;"	d
N_FUN	inc/stab.h	17;"	d
N_GSYM	inc/stab.h	15;"	d
N_LBRAC	inc/stab.h	34;"	d
N_LCSYM	inc/stab.h	19;"	d
N_LENG	inc/stab.h	40;"	d
N_LSYM	inc/stab.h	28;"	d
N_MAIN	inc/stab.h	20;"	d
N_PC	inc/stab.h	21;"	d
N_PSYM	inc/stab.h	31;"	d
N_RBRAC	inc/stab.h	36;"	d
N_RSYM	inc/stab.h	22;"	d
N_SLINE	inc/stab.h	23;"	d
N_SO	inc/stab.h	27;"	d
N_SOL	inc/stab.h	30;"	d
N_SSYM	inc/stab.h	26;"	d
N_STSYM	inc/stab.h	18;"	d
OBJCOPY	GNUmakefile	/^OBJCOPY	:= $(GCCPREFIX)objcopy$/;"	m
OBJDIR	GNUmakefile	/^OBJDIR := obj$/;"	m
OBJDIRS	GNUmakefile	/^OBJDIRS :=$/;"	m
OBJDUMP	GNUmakefile	/^OBJDUMP	:= $(GCCPREFIX)objdump$/;"	m
O_ACCMODE	inc/lib.h	120;"	d
O_CREAT	inc/lib.h	122;"	d
O_EXCL	inc/lib.h	124;"	d
O_MKDIR	inc/lib.h	125;"	d
O_RDONLY	inc/lib.h	117;"	d
O_RDWR	inc/lib.h	119;"	d
O_TRUNC	inc/lib.h	123;"	d
O_WRONLY	inc/lib.h	118;"	d
OpenFile	fs/serv.c	/^struct OpenFile {$/;"	s	file:
PACKAGEDATE	conf/lab.mk	/^PACKAGEDATE=Tue Oct 30 05:30:19 EDT 2007$/;"	m
PADDR	kern/pmap.h	19;"	d
PDX	inc/mmu.h	34;"	d
PDXSHIFT	inc/mmu.h	57;"	d
PERL	GNUmakefile	/^PERL	:= perl$/;"	m
PFTEMP	inc/memlayout.h	130;"	d
PGADDR	inc/mmu.h	44;"	d
PGOFF	inc/mmu.h	41;"	d
PGSHIFT	inc/mmu.h	51;"	d
PGSIZE	inc/mmu.h	50;"	d
PPN	inc/mmu.h	30;"	d
PTE_A	inc/mmu.h	65;"	d
PTE_ADDR	inc/mmu.h	78;"	d
PTE_AVAIL	inc/mmu.h	72;"	d
PTE_COW	lib/fork.c	8;"	d	file:
PTE_D	inc/mmu.h	66;"	d
PTE_MBZ	inc/mmu.h	68;"	d
PTE_P	inc/mmu.h	60;"	d
PTE_PCD	inc/mmu.h	64;"	d
PTE_PS	inc/mmu.h	67;"	d
PTE_PWT	inc/mmu.h	63;"	d
PTE_SHARE	inc/lib.h	77;"	d
PTE_U	inc/mmu.h	62;"	d
PTE_USER	inc/mmu.h	75;"	d
PTE_W	inc/mmu.h	61;"	d
PTSHIFT	inc/mmu.h	54;"	d
PTSIZE	inc/mmu.h	53;"	d
PTX	inc/mmu.h	38;"	d
PTXSHIFT	inc/mmu.h	56;"	d
Page	inc/memlayout.h	/^struct Page {$/;"	s
Page_LIST_entry_t	inc/memlayout.h	/^typedef LIST_ENTRY(Page) Page_LIST_entry_t;$/;"	t
Proghdr	inc/elf.h	/^struct Proghdr {$/;"	s
Pseudodesc	inc/mmu.h	/^struct Pseudodesc {$/;"	s
PushRegs	inc/trap.h	/^struct PushRegs {$/;"	s
RELOC	kern/entry.S	/^#define	RELOC(x) ((x) - KERNBASE)$/;"	d
REQVA	fs/serv.c	31;"	d	file:
ROUNDDOWN	inc/types.h	57;"	d
ROUNDUP	inc/types.h	63;"	d
SCROLLLOCK	kern/console.c	220;"	d	file:
SECTSIZE	boot/main.c	32;"	d	file:
SECTSIZE	fs/fs.h	4;"	d
SEG	inc/mmu.h	144;"	d
SEG	inc/mmu.h	174;"	d
SEG16	inc/mmu.h	178;"	d
SEG_FAULT	inc/mmu.h	172;"	d
SEG_NULL	inc/mmu.h	141;"	d
SEG_NULL	inc/mmu.h	170;"	d
SETCALLGATE	inc/mmu.h	291;"	d
SETGATE	inc/mmu.h	277;"	d
SETTINGLAB	GNUmakefile	/^SETTINGLAB := true$/;"	m
SHIFT	kern/console.c	214;"	d	file:
SIZEOF_STRUCT_TRAPFRAME	inc/trap.h	90;"	d
SOL	GNUmakefile	/^SOL := 0$/;"	m
SRL	kern/entry.S	/^#define SRL(val, shamt)		(((val) >> (shamt)) & ~(-1 << (32 - (shamt))))$/;"	d
STA_A	inc/mmu.h	191;"	d
STA_C	inc/mmu.h	188;"	d
STA_E	inc/mmu.h	187;"	d
STA_R	inc/mmu.h	190;"	d
STA_W	inc/mmu.h	189;"	d
STA_X	inc/mmu.h	186;"	d
STS_CG16	inc/mmu.h	197;"	d
STS_CG32	inc/mmu.h	203;"	d
STS_IG16	inc/mmu.h	199;"	d
STS_IG32	inc/mmu.h	204;"	d
STS_LDT	inc/mmu.h	195;"	d
STS_T16A	inc/mmu.h	194;"	d
STS_T16B	inc/mmu.h	196;"	d
STS_T32A	inc/mmu.h	201;"	d
STS_T32B	inc/mmu.h	202;"	d
STS_TG	inc/mmu.h	198;"	d
STS_TG16	inc/mmu.h	200;"	d
STS_TG32	inc/mmu.h	205;"	d
SYS_cgetc	inc/syscall.h	/^	SYS_cgetc,$/;"	e	enum:__anon3
SYS_cputs	inc/syscall.h	/^	SYS_cputs = 0,$/;"	e	enum:__anon3
SYS_env_destroy	inc/syscall.h	/^	SYS_env_destroy,$/;"	e	enum:__anon3
SYS_env_set_pgfault_upcall	inc/syscall.h	/^	SYS_env_set_pgfault_upcall,$/;"	e	enum:__anon3
SYS_env_set_status	inc/syscall.h	/^	SYS_env_set_status,$/;"	e	enum:__anon3
SYS_env_set_trapframe	inc/syscall.h	/^	SYS_env_set_trapframe,$/;"	e	enum:__anon3
SYS_exofork	inc/syscall.h	/^	SYS_exofork,$/;"	e	enum:__anon3
SYS_getenvid	inc/syscall.h	/^	SYS_getenvid,$/;"	e	enum:__anon3
SYS_ipc_recv	inc/syscall.h	/^	SYS_ipc_recv,$/;"	e	enum:__anon3
SYS_ipc_try_send	inc/syscall.h	/^	SYS_ipc_try_send,$/;"	e	enum:__anon3
SYS_page_alloc	inc/syscall.h	/^	SYS_page_alloc,$/;"	e	enum:__anon3
SYS_page_map	inc/syscall.h	/^	SYS_page_map,$/;"	e	enum:__anon3
SYS_page_unmap	inc/syscall.h	/^	SYS_page_unmap,$/;"	e	enum:__anon3
SYS_yield	inc/syscall.h	/^	SYS_yield,$/;"	e	enum:__anon3
Secthdr	inc/elf.h	/^struct Secthdr {$/;"	s
Segdesc	inc/mmu.h	/^struct Segdesc {$/;"	s
Stab	inc/stab.h	/^struct Stab {$/;"	s
Stat	inc/fd.h	/^struct Stat {$/;"	s
Super	fs/fsformat.c	/^typedef struct Super Super;$/;"	t	typeref:struct:Super	file:
Super	inc/fs.h	/^struct Super {$/;"	s
TAR	GNUmakefile	/^TAR	:= gtar$/;"	m
TIMER_16BIT	inc/timerreg.h	64;"	d
TIMER_BCD	inc/timerreg.h	65;"	d
TIMER_CNTR0	inc/timerreg.h	48;"	d
TIMER_CNTR1	inc/timerreg.h	49;"	d
TIMER_CNTR2	inc/timerreg.h	50;"	d
TIMER_DIV	inc/timerreg.h	43;"	d
TIMER_FREQ	inc/timerreg.h	42;"	d
TIMER_HWSTROBE	inc/timerreg.h	60;"	d
TIMER_INTTC	inc/timerreg.h	55;"	d
TIMER_LATCH	inc/timerreg.h	61;"	d
TIMER_LSB	inc/timerreg.h	62;"	d
TIMER_MODE	inc/timerreg.h	51;"	d
TIMER_MSB	inc/timerreg.h	63;"	d
TIMER_ONESHOT	inc/timerreg.h	56;"	d
TIMER_RATEGEN	inc/timerreg.h	57;"	d
TIMER_SEL0	inc/timerreg.h	52;"	d
TIMER_SEL1	inc/timerreg.h	53;"	d
TIMER_SEL2	inc/timerreg.h	54;"	d
TIMER_SQWAVE	inc/timerreg.h	58;"	d
TIMER_SWSTROBE	inc/timerreg.h	59;"	d
TOP	GNUmakefile	/^TOP = .$/;"	m
TRAPHANDLER	kern/trapentry.S	/^#define TRAPHANDLER(name, num)						\\$/;"	d
TRAPHANDLER_NOEC	kern/trapentry.S	/^#define TRAPHANDLER_NOEC(name, num)					\\$/;"	d
T_ALIGN	inc/trap.h	23;"	d
T_BOUND	inc/trap.h	11;"	d
T_BRKPT	inc/trap.h	9;"	d
T_DBLFLT	inc/trap.h	14;"	d
T_DEBUG	inc/trap.h	7;"	d
T_DEFAULT	inc/trap.h	30;"	d
T_DEVICE	inc/trap.h	13;"	d
T_DIVIDE	inc/trap.h	6;"	d
T_FPERR	inc/trap.h	22;"	d
T_GPFLT	inc/trap.h	19;"	d
T_ILLOP	inc/trap.h	12;"	d
T_MCHK	inc/trap.h	24;"	d
T_NMI	inc/trap.h	8;"	d
T_OFLOW	inc/trap.h	10;"	d
T_PGFLT	inc/trap.h	20;"	d
T_SEGNP	inc/trap.h	17;"	d
T_SIMDERR	inc/trap.h	25;"	d
T_STACK	inc/trap.h	18;"	d
T_SYSCALL	inc/trap.h	29;"	d
T_TSS	inc/trap.h	16;"	d
Taskstate	inc/mmu.h	/^struct Taskstate {$/;"	s
Trapframe	inc/trap.h	/^struct Trapframe {$/;"	s
UENVS	inc/memlayout.h	109;"	d
ULDFLAGS	GNUmakefile	/^ULDFLAGS := -T user\/user.ld$/;"	m
ULIM	inc/memlayout.h	97;"	d
UPAGES	inc/memlayout.h	107;"	d
USED	inc/lib.h	24;"	d
USER_CFLAGS	GNUmakefile	/^USER_CFLAGS := $(CFLAGS) -DJOS_USER -gstabs$/;"	m
USTABDATA	inc/memlayout.h	132;"	d
USTACKTOP	inc/memlayout.h	121;"	d
UTEMP	inc/memlayout.h	127;"	d
UTEMP2	lib/spawn.c	5;"	d	file:
UTEMP2USTACK	lib/spawn.c	4;"	d	file:
UTEMP3	lib/spawn.c	6;"	d	file:
UTEXT	inc/memlayout.h	124;"	d
UTOP	inc/memlayout.h	116;"	d
UTrapframe	inc/trap.h	/^struct UTrapframe {$/;"	s
UVPT	inc/memlayout.h	105;"	d
UXSTACKTOP	inc/memlayout.h	118;"	d
UserStabData	kern/kdebug.c	/^struct UserStabData {$/;"	s	file:
V	conf/env.mk	/^V = @$/;"	m
VPD	inc/mmu.h	35;"	d
VPN	inc/mmu.h	31;"	d
VPT	inc/memlayout.h	94;"	d
WHITESPACE	kern/monitor.c	299;"	d	file:
_ARGSET	inc/args.h	76;"	d
_ARGUSED	inc/args.h	77;"	d
_BSD_EXTENSION	fs/fsformat.c	5;"	d	file:
_CONSOLE_H_	kern/console.h	4;"	d
__va_size	inc/stdarg.h	8;"	d
_alltraps	kern/trapentry.S	/^_alltraps:$/;"	l
_panic	kern/init.c	/^_panic(const char *file, int line, const char *fmt,...)$/;"	f
_panic	lib/panic.c	/^_panic(const char *file, int line, const char *fmt,...)$/;"	f
_pgfault_handler	lib/pgfault.c	/^void (*_pgfault_handler)(struct UTrapframe *utf);$/;"	v
_pgfault_upcall	lib/pfentry.S	/^_pgfault_upcall:$/;"	l
_start	kern/entry.S	/^_start:$/;"	l
_start	lib/entry.S	/^_start:$/;"	l
_warn	kern/init.c	/^_warn(const char *file, int line, const char *fmt,...)$/;"	f
addr_6845	kern/console.c	/^static unsigned addr_6845;$/;"	v	file:
alloc_block	fs/fs.c	/^alloc_block(void)$/;"	f
alloc_block_num	fs/fs.c	/^alloc_block_num(void)$/;"	f
alloc_range	user/testpmap.c	/^alloc_range(int initaddr, int maxpa, int startn) {$/;"	f
allocfile	fs/fsformat.c	/^allocfile(struct File *dirf, const char *name, struct Block **dirb)$/;"	f
args_exist	lib/entry.S	/^args_exist:$/;"	l
argv0	lib/panic.c	/^char *argv0;$/;"	v
assert	inc/assert.h	14;"	d
basemem	kern/pmap.c	/^static size_t basemem;		\/\/ Amount of base memory (in bytes)$/;"	v	file:
binaryname	lib/libmain.c	/^char *binaryname = "(PROGRAM NAME UNKNOWN)";$/;"	v
bitmap	fs/fs.c	/^uint32_t *bitmap;		\/\/ bitmap blocks mapped in memory$/;"	v
block_is_dirty	fs/fs.c	/^block_is_dirty(uint32_t blockno)$/;"	f
block_is_free	fs/fs.c	/^block_is_free(uint32_t blockno)$/;"	f
block_is_mapped	fs/fs.c	/^block_is_mapped(uint32_t blockno)$/;"	f
bno	fs/fsformat.c	/^	uint32_t bno;$/;"	m	struct:Block	file:
bol	user/num.c	/^int bol = 1;$/;"	v
bool	fs/fsformat.c	/^typedef int bool;$/;"	t	file:
bool	fs/fsformat.c	23;"	d	file:
bool	fs/fsformat.c	9;"	d	file:
bool	inc/types.h	/^typedef int bool;$/;"	t
boot_alloc	kern/pmap.c	/^boot_alloc(uint32_t n, uint32_t align)$/;"	f	file:
boot_cr3	kern/pmap.c	/^physaddr_t boot_cr3;		\/\/ Physical address of boot time page directory$/;"	v
boot_freemem	kern/pmap.c	/^static char* boot_freemem;	\/\/ Pointer to next byte of free mem   --- char*为什么用来指向地址？$/;"	v	file:
boot_map_segment	kern/pmap.c	/^boot_map_segment(pde_t *pgdir, uintptr_t la, size_t size, physaddr_t pa, int perm)$/;"	f	file:
boot_pgdir	kern/pmap.c	/^pde_t* boot_pgdir;		\/\/ Virtual address of boot time page directory$/;"	v
bootmain	boot/main.c	/^bootmain(void)$/;"	f
bootstack	kern/entry.S	/^bootstack:$/;"	l
bootstacktop	kern/entry.S	/^bootstacktop:$/;"	l
breakpoint	inc/x86.h	/^breakpoint(void)$/;"	f
bss	user/init.c	/^char bss[6000];$/;"	v
buf	fs/fsformat.c	/^	uint8_t buf[BLKSIZE];$/;"	m	struct:Block	file:
buf	kern/console.c	/^	uint8_t buf[CONSBUFSIZE];$/;"	m	struct:__anon1	file:
buf	lib/fprintf.c	/^	char buf[256];$/;"	m	struct:printbuf	file:
buf	lib/printf.c	/^	char buf[256];$/;"	m	struct:printbuf	file:
buf	lib/printfmt.c	/^	char *buf;$/;"	m	struct:sprintbuf	file:
buf	lib/readline.c	/^static char buf[BUFLEN];$/;"	v	file:
buf	user/cat.c	/^char buf[8192];$/;"	v
busy	fs/fsformat.c	/^	uint32_t busy;$/;"	m	struct:Block	file:
cache	fs/fsformat.c	/^struct Block cache[16];$/;"	v	typeref:struct:Block
cat	user/cat.c	/^cat(int f, char *s)$/;"	f
cga_init	kern/console.c	/^cga_init(void)$/;"	f
cga_putc	kern/console.c	/^cga_putc(int c)$/;"	f
char_map	kern/monitor.c	/^char char_map(uintptr_t i){$/;"	f
charcode	kern/console.c	/^static uint8_t *charcode[4] = {$/;"	v	file:
check_boot_pgdir	kern/pmap.c	/^check_boot_pgdir(void)$/;"	f	file:
check_page_alloc	kern/pmap.c	/^check_page_alloc()$/;"	f	file:
check_va2pa	kern/pmap.c	/^check_va2pa(pde_t *pgdir, uintptr_t va)$/;"	f	file:
check_write_block	fs/fs.c	/^check_write_block(void)$/;"	f
close	lib/fd.c	/^close(int fdnum)$/;"	f
close_all	lib/fd.c	/^close_all(void)$/;"	f
cnt	lib/printf.c	/^	int cnt;	\/\/ total bytes printed so far$/;"	m	struct:printbuf	file:
cnt	lib/printfmt.c	/^	int cnt;$/;"	m	struct:sprintbuf	file:
commands	kern/monitor.c	/^static struct Command commands[] = {$/;"	v	typeref:struct:Command	file:
cons	kern/console.c	/^} cons;$/;"	v	typeref:struct:__anon1	file:
cons_getc	kern/console.c	/^cons_getc(void)$/;"	f
cons_init	kern/console.c	/^cons_init(void)$/;"	f
cons_intr	kern/console.c	/^cons_intr(int (*proc)(void))$/;"	f
cons_putc	kern/console.c	/^cons_putc(int c)$/;"	f
continuetest	grade.sh	/^continuetest () {$/;"	f
cprintf	kern/printf.c	/^cprintf(const char *fmt, ...)$/;"	f
cprintf	lib/printf.c	/^cprintf(const char *fmt, ...)$/;"	f
cpuid	inc/x86.h	/^cpuid(uint32_t info, uint32_t *eaxp, uint32_t *ebxp, uint32_t *ecxp, uint32_t *edxp)$/;"	f
cputchar	kern/console.c	/^cputchar(int c)$/;"	f
cputchar	lib/console.c	/^cputchar(int ch)$/;"	f
crt_buf	kern/console.c	/^static uint16_t *crt_buf;$/;"	v	file:
crt_pos	kern/console.c	/^static uint16_t crt_pos;$/;"	v	file:
ctlmap	kern/console.c	/^static uint8_t ctlmap[256] = $/;"	v	file:
curenv	kern/env.c	/^struct Env *curenv = NULL;	        \/\/ The current env$/;"	v	typeref:struct:Env
data	user/init.c	/^} data = {$/;"	v	typeref:struct:__anon5
debug	fs/serv.c	12;"	d	file:
debug	lib/fd.c	3;"	d	file:
debug	lib/file.c	5;"	d	file:
debug	lib/fsipc.c	4;"	d	file:
debuginfo_eip	kern/kdebug.c	/^debuginfo_eip(uintptr_t addr, struct Eipdebuginfo *info)$/;"	f
delay	kern/console.c	/^delay(void)$/;"	f	file:
desc	kern/monitor.c	/^	const char *desc;$/;"	m	struct:Command	file:
dev_close	inc/fd.h	/^	int (*dev_close)(struct Fd *fd);$/;"	m	struct:Dev
dev_id	inc/fd.h	/^	int dev_id;$/;"	m	struct:Dev
dev_lookup	lib/fd.c	/^dev_lookup(int dev_id, struct Dev **dev)$/;"	f
dev_name	inc/fd.h	/^	char *dev_name;$/;"	m	struct:Dev
dev_read	inc/fd.h	/^	ssize_t (*dev_read)(struct Fd *fd, void *buf, size_t len, off_t offset);$/;"	m	struct:Dev
dev_seek	inc/fd.h	/^	int (*dev_seek)(struct Fd *fd, off_t pos);$/;"	m	struct:Dev
dev_stat	inc/fd.h	/^	int (*dev_stat)(struct Fd *fd, struct Stat *stat);$/;"	m	struct:Dev
dev_trunc	inc/fd.h	/^	int (*dev_trunc)(struct Fd *fd, off_t length);$/;"	m	struct:Dev
dev_write	inc/fd.h	/^	ssize_t (*dev_write)(struct Fd *fd, const void *buf, size_t len, off_t offset);$/;"	m	struct:Dev
devfile	lib/file.c	/^struct Dev devfile =$/;"	v	typeref:struct:Dev
devtab	lib/fd.c	/^static struct Dev *devtab[] =$/;"	v	typeref:struct:Dev	file:
didinit	kern/picirq.c	/^static bool didinit;$/;"	v	file:
dir_alloc_file	fs/fs.c	/^dir_alloc_file(struct File *dir, struct File **file)$/;"	f
dir_lookup	fs/fs.c	/^dir_lookup(struct File *dir, const char *name, struct File **file)$/;"	f
diskaddr	fs/fs.c	/^diskaddr(uint32_t blockno)$/;"	f
diskfd	fs/fsformat.c	/^int diskfd;$/;"	v
diskno	fs/ide.c	/^static int diskno = 1;$/;"	v	file:
dup	lib/fd.c	/^dup(int oldfdnum, int newfdnum)$/;"	f
duplicate_range	user/testpmap.c	/^duplicate_range(int startva, int dupeva, int nbytes) {$/;"	f
duppage	lib/fork.c	/^duppage(envid_t envid, unsigned pn)$/;"	f	file:
e_ehsize	inc/elf.h	/^	uint16_t e_ehsize;$/;"	m	struct:Elf
e_elf	inc/elf.h	/^	uint8_t e_elf[12];$/;"	m	struct:Elf
e_entry	inc/elf.h	/^	uint32_t e_entry;$/;"	m	struct:Elf
e_flags	inc/elf.h	/^	uint32_t e_flags;$/;"	m	struct:Elf
e_machine	inc/elf.h	/^	uint16_t e_machine;$/;"	m	struct:Elf
e_magic	inc/elf.h	/^	uint32_t e_magic;	\/\/ must equal ELF_MAGIC$/;"	m	struct:Elf
e_phentsize	inc/elf.h	/^	uint16_t e_phentsize;$/;"	m	struct:Elf
e_phnum	inc/elf.h	/^	uint16_t e_phnum;$/;"	m	struct:Elf
e_phoff	inc/elf.h	/^	uint32_t e_phoff;$/;"	m	struct:Elf
e_shentsize	inc/elf.h	/^	uint16_t e_shentsize;$/;"	m	struct:Elf
e_shnum	inc/elf.h	/^	uint16_t e_shnum;$/;"	m	struct:Elf
e_shoff	inc/elf.h	/^	uint32_t e_shoff;$/;"	m	struct:Elf
e_shstrndx	inc/elf.h	/^	uint16_t e_shstrndx;$/;"	m	struct:Elf
e_type	inc/elf.h	/^	uint16_t e_type;$/;"	m	struct:Elf
e_version	inc/elf.h	/^	uint32_t e_version;$/;"	m	struct:Elf
ebuf	lib/printfmt.c	/^	char *ebuf;$/;"	m	struct:sprintbuf	file:
echo_n	grade.sh	/^echo_n () {$/;"	f
eip_file	kern/kdebug.h	/^	const char *eip_file;		\/\/ Source code filename for EIP$/;"	m	struct:Eipdebuginfo
eip_fn_addr	kern/kdebug.h	/^	uintptr_t eip_fn_addr;		\/\/ Address of start of function$/;"	m	struct:Eipdebuginfo
eip_fn_name	kern/kdebug.h	/^	const char *eip_fn_name;	\/\/ Name of function containing EIP$/;"	m	struct:Eipdebuginfo
eip_fn_namelen	kern/kdebug.h	/^	int eip_fn_namelen;		\/\/ Length of function name$/;"	m	struct:Eipdebuginfo
eip_fn_narg	kern/kdebug.h	/^	int eip_fn_narg;		\/\/ Number of function arguments$/;"	m	struct:Eipdebuginfo
eip_line	kern/kdebug.h	/^	int eip_line;			\/\/ Source code linenumber for EIP$/;"	m	struct:Eipdebuginfo
env	lib/libmain.c	/^volatile struct Env *env;$/;"	v	typeref:struct:Env
env_alloc	kern/env.c	/^env_alloc(struct Env **newenv_store, envid_t parent_id)$/;"	f
env_cr3	inc/env.h	/^	physaddr_t env_cr3;		\/\/ Physical address of page dir$/;"	m	struct:Env
env_create	kern/env.c	/^env_create(uint8_t *binary, size_t size)$/;"	f
env_destroy	kern/env.c	/^env_destroy(struct Env *e) $/;"	f
env_free	kern/env.c	/^env_free(struct Env *e)$/;"	f
env_free_list	kern/env.c	/^static struct Env_list env_free_list;	\/\/ Free list$/;"	v	typeref:struct:Env_list	file:
env_id	inc/env.h	/^	envid_t env_id;			\/\/ Unique environment identifier$/;"	m	struct:Env
env_init	kern/env.c	/^env_init(void)$/;"	f
env_ipc_dstva	inc/env.h	/^	void *env_ipc_dstva;		\/\/ va at which to map received page$/;"	m	struct:Env
env_ipc_from	inc/env.h	/^	envid_t env_ipc_from;		\/\/ envid of the sender	$/;"	m	struct:Env
env_ipc_perm	inc/env.h	/^	int env_ipc_perm;		\/\/ perm of page mapping received$/;"	m	struct:Env
env_ipc_recving	inc/env.h	/^	bool env_ipc_recving;		\/\/ env is blocked receiving$/;"	m	struct:Env
env_ipc_value	inc/env.h	/^	uint32_t env_ipc_value;		\/\/ data value sent to us $/;"	m	struct:Env
env_link	inc/env.h	/^	LIST_ENTRY(Env) env_link;	\/\/ Free list link pointers$/;"	m	struct:Env
env_parent_id	inc/env.h	/^	envid_t env_parent_id;		\/\/ env_id of this env's parent$/;"	m	struct:Env
env_pgdir	inc/env.h	/^	pde_t *env_pgdir;		\/\/ Kernel virtual address of page dir$/;"	m	struct:Env
env_pgfault_upcall	inc/env.h	/^	void *env_pgfault_upcall;	\/\/ page fault upcall entry point$/;"	m	struct:Env
env_pop_tf	kern/env.c	/^env_pop_tf(struct Trapframe *tf)$/;"	f
env_run	kern/env.c	/^env_run(struct Env *e)$/;"	f
env_runs	inc/env.h	/^	uint32_t env_runs;		\/\/ Number of times environment has run$/;"	m	struct:Env
env_setup_vm	kern/env.c	/^env_setup_vm(struct Env *e)$/;"	f	file:
env_status	inc/env.h	/^	unsigned env_status;		\/\/ Status of the environment$/;"	m	struct:Env
env_tf	inc/env.h	/^	struct Trapframe env_tf;	\/\/ Saved registers$/;"	m	struct:Env	typeref:struct:Env::Trapframe
envid2env	kern/env.c	/^envid2env(envid_t envid, struct Env **env_store, bool checkperm)$/;"	f
envid_t	inc/env.h	/^typedef int32_t envid_t;$/;"	t
envs	kern/env.c	/^struct Env *envs = NULL;		\/\/ All environments$/;"	v	typeref:struct:Env
error	lib/fprintf.c	/^	int error;	\/\/ first error that occurred$/;"	m	struct:printbuf	file:
error_string	lib/printfmt.c	/^static const char * const error_string[MAXERROR + 1] =$/;"	v	file:
exit	lib/exit.c	/^exit(void)$/;"	f
extmem	kern/pmap.c	/^static size_t extmem;		\/\/ Amount of extended memory (in bytes)$/;"	v	file:
f_dir	inc/fs.h	/^	struct File *f_dir;$/;"	m	struct:File	typeref:struct:File::File
f_direct	inc/fs.h	/^	uint32_t f_direct[NDIRECT];	\/\/ direct blocks$/;"	m	struct:File
f_indirect	inc/fs.h	/^	uint32_t f_indirect;		\/\/ indirect block$/;"	m	struct:File
f_name	inc/fs.h	/^	char f_name[MAXNAMELEN];	\/\/ filename$/;"	m	struct:File
f_pad	inc/fs.h	/^	uint8_t f_pad[256 - MAXNAMELEN - 8 - 4*NDIRECT - 4 - sizeof(struct File*)];$/;"	m	struct:File
f_size	inc/fs.h	/^	off_t f_size;			\/\/ file size in bytes$/;"	m	struct:File
f_type	inc/fs.h	/^	uint32_t f_type;		\/\/ file type$/;"	m	struct:File
failures	user/testpmap.c	/^int n, va, r, initva, maxpa, maxva, maxnum, failures;$/;"	v
fd	lib/fprintf.c	/^	int fd;		\/\/ file descriptor$/;"	m	struct:printbuf	file:
fd2data	lib/fd.c	/^fd2data(struct Fd *fd)$/;"	f
fd2num	lib/fd.c	/^fd2num(struct Fd *fd)$/;"	f
fd_alloc	lib/fd.c	/^fd_alloc(struct Fd **fd_store)$/;"	f
fd_close	lib/fd.c	/^fd_close(struct Fd *fd, bool must_exist)$/;"	f
fd_dev_id	inc/fd.h	/^	int fd_dev_id;$/;"	m	struct:Fd
fd_file	inc/fd.h	/^		struct FdFile fd_file;$/;"	m	union:Fd::__anon2	typeref:struct:Fd::__anon2::FdFile
fd_lookup	lib/fd.c	/^fd_lookup(int fdnum, struct Fd **fd_store)$/;"	f
fd_offset	inc/fd.h	/^	off_t fd_offset;$/;"	m	struct:Fd
fd_omode	inc/fd.h	/^	int fd_omode;$/;"	m	struct:Fd
fdtab	lib/entry.S	/^fdtab:$/;"	l
file	inc/fd.h	/^	struct File file;$/;"	m	struct:FdFile	typeref:struct:FdFile::File
file_block_walk	fs/fs.c	/^file_block_walk(struct File *f, uint32_t filebno, uint32_t **ppdiskbno, bool alloc)$/;"	f
file_clear_block	fs/fs.c	/^file_clear_block(struct File *f, uint32_t filebno)$/;"	f
file_close	fs/fs.c	/^file_close(struct File *f)$/;"	f
file_close	lib/file.c	/^file_close(struct Fd *fd)$/;"	f	file:
file_create	fs/fs.c	/^file_create(const char *path, struct File **pf)$/;"	f
file_dirty	fs/fs.c	/^file_dirty(struct File *f, off_t offset)$/;"	f
file_flush	fs/fs.c	/^file_flush(struct File *f)$/;"	f
file_get_block	fs/fs.c	/^file_get_block(struct File *f, uint32_t filebno, char **blk)$/;"	f
file_map_block	fs/fs.c	/^file_map_block(struct File *f, uint32_t filebno, uint32_t *diskbno, bool alloc)$/;"	f
file_open	fs/fs.c	/^file_open(const char *path, struct File **pf)$/;"	f
file_read	lib/file.c	/^file_read(struct Fd *fd, void *buf, size_t n, off_t offset)$/;"	f	file:
file_remove	fs/fs.c	/^file_remove(const char *path)$/;"	f
file_set_size	fs/fs.c	/^file_set_size(struct File *f, off_t newsize)$/;"	f
file_stat	lib/file.c	/^file_stat(struct Fd *fd, struct Stat *st)$/;"	f	file:
file_trunc	lib/file.c	/^file_trunc(struct Fd *fd, off_t newsize)$/;"	f	file:
file_truncate_blocks	fs/fs.c	/^file_truncate_blocks(struct File *f, off_t newsize)$/;"	f	file:
file_write	lib/file.c	/^file_write(struct Fd *fd, const void *buf, size_t n, off_t offset)$/;"	f	file:
finishfs	fs/fsformat.c	/^finishfs(void)$/;"	f
flag	user/ls.c	/^int flag[256];$/;"	v
flushb	fs/fsformat.c	/^flushb(struct Block *b)$/;"	f
flushdisk	fs/fsformat.c	/^flushdisk(void)$/;"	f
fmap	lib/file.c	/^fmap(struct Fd* fd, off_t oldsize, off_t newsize)$/;"	f	file:
fork	lib/fork.c	/^fork(void)$/;"	f
forkchild	user/forktree.c	/^forkchild(const char *cur, char branch)$/;"	f
forktree	user/forktree.c	/^forktree(const char *cur)$/;"	f
fprintf	lib/fprintf.c	/^fprintf(int fd, const char *fmt, ...)$/;"	f
free_block	fs/fs.c	/^free_block(uint32_t blockno)$/;"	f
fs_init	fs/fs.c	/^fs_init(void)$/;"	f
fs_sync	fs/fs.c	/^fs_sync(void)$/;"	f
fs_test	fs/test.c	/^fs_test(void)$/;"	f
fsipc	lib/fsipc.c	/^fsipc(unsigned type, void *fsreq, void *dstva, int *perm)$/;"	f	file:
fsipc_close	lib/fsipc.c	/^fsipc_close(int fileid)$/;"	f
fsipc_dirty	lib/fsipc.c	/^fsipc_dirty(int fileid, off_t offset)$/;"	f
fsipc_map	lib/fsipc.c	/^fsipc_map(int fileid, off_t offset, void *dstva)$/;"	f
fsipc_open	lib/fsipc.c	/^fsipc_open(const char *path, int omode, struct Fd *fd)$/;"	f
fsipc_remove	lib/fsipc.c	/^fsipc_remove(const char *path)$/;"	f
fsipc_set_size	lib/fsipc.c	/^fsipc_set_size(int fileid, off_t size)$/;"	f
fsipc_sync	lib/fsipc.c	/^fsipc_sync(void)$/;"	f
fsipcbuf	lib/entry.S	/^fsipcbuf:$/;"	l
fstat	lib/fd.c	/^fstat(int fdnum, struct Stat *stat)$/;"	f
ftruncate	lib/fd.c	/^ftruncate(int fdnum, off_t newsize)$/;"	f
func	kern/monitor.c	/^	int (*func)(int argc, char** argv, struct Trapframe* tf);$/;"	m	struct:Command	file:
funmap	lib/file.c	/^funmap(struct Fd* fd, off_t oldsize, off_t newsize, bool dirty)$/;"	f	file:
gd_args	inc/mmu.h	/^	unsigned gd_args : 5;        \/\/ # args, 0 for interrupt\/trap gates$/;"	m	struct:Gatedesc
gd_dpl	inc/mmu.h	/^	unsigned gd_dpl : 2;         \/\/ descriptor(meaning new) privilege level$/;"	m	struct:Gatedesc
gd_off_15_0	inc/mmu.h	/^	unsigned gd_off_15_0 : 16;   \/\/ low 16 bits of offset in segment$/;"	m	struct:Gatedesc
gd_off_31_16	inc/mmu.h	/^	unsigned gd_off_31_16 : 16;  \/\/ high bits of offset in segment$/;"	m	struct:Gatedesc
gd_p	inc/mmu.h	/^	unsigned gd_p : 1;           \/\/ Present$/;"	m	struct:Gatedesc
gd_rsv1	inc/mmu.h	/^	unsigned gd_rsv1 : 3;        \/\/ reserved(should be zero I guess)$/;"	m	struct:Gatedesc
gd_s	inc/mmu.h	/^	unsigned gd_s : 1;           \/\/ must be 0 (system)$/;"	m	struct:Gatedesc
gd_ss	inc/mmu.h	/^	unsigned gd_ss : 16;         \/\/ segment selector$/;"	m	struct:Gatedesc
gd_type	inc/mmu.h	/^	unsigned gd_type : 4;        \/\/ type(STS_{TG,IG32,TG32})$/;"	m	struct:Gatedesc
gdt	boot/boot.S	/^gdt:$/;"	l
gdt	kern/pmap.c	/^struct Segdesc gdt[] =$/;"	v	typeref:struct:Segdesc
gdt_pd	kern/pmap.c	/^struct Pseudodesc gdt_pd = {$/;"	v	typeref:struct:Pseudodesc
gdtdesc	boot/boot.S	/^gdtdesc:$/;"	l
getblk	fs/fsformat.c	/^getblk(uint32_t bno, int clr, uint32_t type)$/;"	f
getchar	kern/console.c	/^getchar(void)$/;"	f
getchar	lib/console.c	/^getchar(void)$/;"	f
getint	lib/printfmt.c	/^getint(va_list *ap, int lflag)$/;"	f	file:
getuint	lib/printfmt.c	/^getuint(va_list *ap, int lflag)$/;"	f	file:
i386_detect_memory	kern/pmap.c	/^i386_detect_memory(void)$/;"	f
i386_init	kern/init.c	/^i386_init(void)$/;"	f
i386_vm_init	kern/pmap.c	/^i386_vm_init(void)$/;"	f
id	inc/fd.h	/^	int id;$/;"	m	struct:FdFile
ide_probe_disk1	fs/ide.c	/^ide_probe_disk1(void)$/;"	f
ide_read	fs/ide.c	/^ide_read(uint32_t secno, void *dst, size_t nsecs)$/;"	f
ide_set_disk	fs/ide.c	/^ide_set_disk(int d)$/;"	f
ide_wait_ready	fs/ide.c	/^ide_wait_ready(bool check_error)$/;"	f	file:
ide_write	fs/ide.c	/^ide_write(uint32_t secno, const void *src, size_t nsecs)$/;"	f
idt	kern/trap.c	/^struct Gatedesc idt[256] = { { 0 } };$/;"	v	typeref:struct:Gatedesc
idt_init	kern/trap.c	/^idt_init(void)$/;"	f
idt_pd	kern/trap.c	/^struct Pseudodesc idt_pd = {$/;"	v	typeref:struct:Pseudodesc
idthdr	kern/trapentry.S	/^idthdr:$/;"	l
idthdr_entry	kern/trap.c	/^struct idthdr_entry {$/;"	s	file:
idx	lib/fprintf.c	/^	int idx;	\/\/ current buffer index$/;"	m	struct:printbuf	file:
idx	lib/printf.c	/^	int idx;	\/\/ current buffer index$/;"	m	struct:printbuf	file:
inb	inc/x86.h	/^inb(int port)$/;"	f
init_stack	lib/spawn.c	/^init_stack(envid_t child, const char **argv, uintptr_t *init_esp)$/;"	f	file:
initva	user/testpmap.c	/^int n, va, r, initva, maxpa, maxva, maxnum, failures;$/;"	v
inl	inc/x86.h	/^inl(int port)$/;"	f
insb	inc/x86.h	/^insb(int port, void *addr, int cnt)$/;"	f
insl	inc/x86.h	/^insl(int port, void *addr, int cnt)$/;"	f
insw	inc/x86.h	/^insw(int port, void *addr, int cnt)$/;"	f
int16_t	inc/types.h	/^typedef short int16_t;$/;"	t
int32_t	inc/types.h	/^typedef int int32_t;$/;"	t
int64_t	inc/types.h	/^typedef long long int64_t;$/;"	t
int8_t	inc/types.h	/^typedef __signed char int8_t;$/;"	t
intptr_t	inc/types.h	/^typedef int32_t intptr_t;$/;"	t
invlpg	inc/x86.h	/^invlpg(void *addr)$/;"	f
inw	inc/x86.h	/^inw(int port)$/;"	f
ipc_recv	lib/ipc.c	/^ipc_recv(envid_t *from_env_store, void *pg, int *perm_store)$/;"	f
ipc_send	lib/ipc.c	/^ipc_send(envid_t to_env, uint32_t val, void *pg, int perm)$/;"	f
irq_mask_8259A	kern/picirq.c	/^uint16_t irq_mask_8259A = 0xFFFF & ~(1<<IRQ_SLAVE);$/;"	v
irq_setmask_8259A	kern/picirq.c	/^irq_setmask_8259A(uint16_t mask)$/;"	f
iscons	kern/console.c	/^iscons(int fdnum)$/;"	f
kbd_init	kern/console.c	/^kbd_init(void)$/;"	f
kbd_intr	kern/console.c	/^kbd_intr(void)$/;"	f
kbd_proc_data	kern/console.c	/^kbd_proc_data(void)$/;"	f	file:
kclock_init	kern/kclock.c	/^kclock_init(void)$/;"	f
lcr0	inc/x86.h	/^lcr0(uint32_t val)$/;"	f
lcr3	inc/x86.h	/^lcr3(uint32_t val)$/;"	f
lcr4	inc/x86.h	/^lcr4(uint32_t val)$/;"	f
libmain	lib/libmain.c	/^libmain(int argc, char **argv)$/;"	f
lidt	inc/x86.h	/^lidt(void *p)$/;"	f
line	user/num.c	/^int line = 0;$/;"	v
lldt	inc/x86.h	/^lldt(uint16_t sel)$/;"	f
load_icode	kern/env.c	/^load_icode(struct Env *e, uint8_t *binary, size_t size)$/;"	f	file:
lpt_putc	kern/console.c	/^lpt_putc(int c)$/;"	f	file:
ls	user/ls.c	/^ls(const char *path, const char *prefix)$/;"	f
ls1	user/ls.c	/^ls1(const char *prefix, bool isdir, off_t size, const char *name)$/;"	f
lsdir	user/ls.c	/^lsdir(const char *path, const char *prefix)$/;"	f
ltr	inc/x86.h	/^ltr(uint16_t sel)$/;"	f
main	fs/fsformat.c	/^main(int argc, char **argv)$/;"	f
map_block	fs/fs.c	/^map_block(uint32_t blockno)$/;"	f
mark_page	user/testpmap.c	/^mark_page(int* pg, int i) {$/;"	f
maxnum	user/testpmap.c	/^int n, va, r, initva, maxpa, maxva, maxnum, failures;$/;"	v
maxpa	kern/pmap.c	/^static physaddr_t maxpa;	\/\/ Maximum physical address$/;"	v	file:
maxpa	user/testpmap.c	/^int n, va, r, initva, maxpa, maxva, maxnum, failures;$/;"	v
maxva	user/testpmap.c	/^int n, va, r, initva, maxpa, maxva, maxnum, failures;$/;"	v
mc146818_read	kern/kclock.c	/^mc146818_read(unsigned reg)$/;"	f
mc146818_write	kern/kclock.c	/^mc146818_write(unsigned reg, unsigned datum)$/;"	f
memcmp	lib/string.c	/^memcmp(const void *v1, const void *v2, size_t n)$/;"	f
memcpy	lib/string.c	/^memcpy(void *dst, void *src, size_t n)$/;"	f
memfind	lib/string.c	/^memfind(const void *s, int c, size_t n)$/;"	f
memmove	lib/string.c	/^memmove(void *dst, const void *src, size_t n)$/;"	f
memset	lib/string.c	/^memset(void *v, int c, size_t n)$/;"	f
mon_alloc_page	kern/monitor.c	/^mon_alloc_page(int argc, char **argv, struct Trapframe *tf)$/;"	f
mon_backtrace	kern/monitor.c	/^mon_backtrace(int argc, char **argv, struct Trapframe *tf)$/;"	f
mon_dump_pa	kern/monitor.c	/^int mon_dump_pa(int argc, char **argv, struct Trapframe *tf)$/;"	f
mon_dump_va	kern/monitor.c	/^int mon_dump_va(int argc, char **argv, struct Trapframe *tf)$/;"	f
mon_free_page	kern/monitor.c	/^mon_free_page(int argc, char **argv, struct Trapframe *tf)$/;"	f
mon_help	kern/monitor.c	/^mon_help(int argc, char **argv, struct Trapframe *tf)$/;"	f
mon_kerninfo	kern/monitor.c	/^mon_kerninfo(int argc, char **argv, struct Trapframe *tf)$/;"	f
mon_page_status	kern/monitor.c	/^mon_page_status(int argc, char **argv, struct Trapframe *tf)$/;"	f
mon_set_perm	kern/monitor.c	/^mon_set_perm(int argc, char **argv, struct Trapframe *tf)$/;"	f
mon_show_map	kern/monitor.c	/^mon_show_map(int argc, char **argv, struct Trapframe *tf)$/;"	f
monitor	kern/monitor.c	/^monitor(struct Trapframe *tf)$/;"	f
msg	fs/test.c	/^static char *msg = "This is the NEW message of the day!\\n\\n";$/;"	v	file:
msg	user/testfsipc.c	/^const char *msg = "This is the NEW message of the day!\\n\\n";$/;"	v
msg1	user/init.c	/^	char msg1[5000];$/;"	m	struct:__anon5	file:
msg2	user/init.c	/^	char msg2[1000];$/;"	m	struct:__anon5	file:
mygdt	kern/entry.S	/^mygdt:$/;"	l
mygdtdesc	kern/entry.S	/^mygdtdesc:$/;"	l
n	user/testpmap.c	/^int n, va, r, initva, maxpa, maxva, maxnum, failures;$/;"	v
n_desc	inc/stab.h	/^	uint16_t n_desc;        \/\/ description field$/;"	m	struct:Stab
n_other	inc/stab.h	/^	uint8_t n_other;        \/\/ misc info (usually empty)$/;"	m	struct:Stab
n_strx	inc/stab.h	/^	uint32_t n_strx;	\/\/ index into string table of name$/;"	m	struct:Stab
n_type	inc/stab.h	/^	uint8_t n_type;         \/\/ type of symbol$/;"	m	struct:Stab
n_value	inc/stab.h	/^	uintptr_t n_value;	\/\/ value of symbol$/;"	m	struct:Stab
name	kern/monitor.c	/^	const char *name;$/;"	m	struct:Command	file:
name	kern/trap.c	/^	long name;$/;"	m	struct:idthdr_entry	file:
name	kern/trapentry.S	/^	name:								\\$/;"	l
name	kern/trapentry.S	/^	name:			\/* function starts here *\/		\\$/;"	l
nbitblock	fs/fsformat.c	/^uint32_t nbitblock;$/;"	v
nblocks	fs/fsformat.c	/^uint32_t nblocks;$/;"	v
nelem	fs/fsformat.c	36;"	d	file:
nextb	fs/fsformat.c	/^uint32_t nextb;$/;"	v
normalmap	kern/console.c	/^static uint8_t normalmap[256] =$/;"	v	file:
npage	kern/pmap.c	/^size_t npage;			\/\/ Amount of physical memory (in pages)$/;"	v
num	kern/trap.c	/^	long num;$/;"	m	struct:idthdr_entry	file:
num	user/num.c	/^num(int f, char *s)$/;"	f
nvram_read	kern/pmap.c	/^nvram_read(int r)$/;"	f	file:
o_fd	fs/serv.c	/^	struct Fd *o_fd;	\/\/ Fd page$/;"	m	struct:OpenFile	typeref:struct:OpenFile::Fd	file:
o_file	fs/serv.c	/^	struct File *o_file;	\/\/ mapped descriptor for open file$/;"	m	struct:OpenFile	typeref:struct:OpenFile::File	file:
o_fileid	fs/serv.c	/^	uint32_t o_fileid;	\/\/ file id$/;"	m	struct:OpenFile	file:
o_mode	fs/serv.c	/^	int o_mode;		\/\/ open mode$/;"	m	struct:OpenFile	file:
off_t	fs/fsformat.c	/^typedef uint32_t off_t;$/;"	t	file:
off_t	fs/fsformat.c	22;"	d	file:
off_t	fs/fsformat.c	8;"	d	file:
off_t	inc/types.h	/^typedef int32_t off_t;$/;"	t
offsetof	inc/types.h	70;"	d
open	lib/file.c	/^open(const char *path, int mode)$/;"	f
opendisk	fs/fsformat.c	/^opendisk(const char *name)$/;"	f
openfile_alloc	fs/serv.c	/^openfile_alloc(struct OpenFile **o)$/;"	f
openfile_lookup	fs/serv.c	/^openfile_lookup(envid_t envid, uint32_t fileid, struct OpenFile **po)$/;"	f
opentab	fs/serv.c	/^struct OpenFile opentab[MAXOPEN] = {$/;"	v	typeref:struct:OpenFile
outb	inc/x86.h	/^outb(int port, uint8_t data)$/;"	f
outl	inc/x86.h	/^outl(int port, uint32_t data)$/;"	f
outsb	inc/x86.h	/^outsb(int port, const void *addr, int cnt)$/;"	f
outsl	inc/x86.h	/^outsl(int port, const void *addr, int cnt)$/;"	f
outsw	inc/x86.h	/^outsw(int port, const void *addr, int cnt)$/;"	f
outw	inc/x86.h	/^outw(int port, uint16_t data)$/;"	f
p_align	inc/elf.h	/^	uint32_t p_align;$/;"	m	struct:Proghdr
p_filesz	inc/elf.h	/^	uint32_t p_filesz;$/;"	m	struct:Proghdr
p_flags	inc/elf.h	/^	uint32_t p_flags;$/;"	m	struct:Proghdr
p_memsz	inc/elf.h	/^	uint32_t p_memsz;$/;"	m	struct:Proghdr
p_offset	inc/elf.h	/^	uint32_t p_offset;$/;"	m	struct:Proghdr
p_pa	inc/elf.h	/^	uint32_t p_pa;$/;"	m	struct:Proghdr
p_type	inc/elf.h	/^	uint32_t p_type;$/;"	m	struct:Proghdr
p_va	inc/elf.h	/^	uint32_t p_va;$/;"	m	struct:Proghdr
pa2page	kern/pmap.h	/^pa2page(physaddr_t pa)$/;"	f
page2kva	kern/pmap.h	/^page2kva(struct Page *pp)$/;"	f
page2pa	kern/pmap.h	/^page2pa(struct Page *pp)$/;"	f
page2ppn	kern/pmap.h	/^page2ppn(struct Page *pp)$/;"	f
page_alloc	kern/pmap.c	/^page_alloc(struct Page **pp_store)$/;"	f
page_check	kern/pmap.c	/^page_check(void)$/;"	f	file:
page_decref	kern/pmap.c	/^page_decref(struct Page* pp)$/;"	f
page_fault_handler	kern/trap.c	/^page_fault_handler(struct Trapframe *tf)$/;"	f
page_free	kern/pmap.c	/^page_free(struct Page *pp)$/;"	f
page_free_list	kern/pmap.c	/^static struct Page_list page_free_list;	\/\/ Free list of physical pages$/;"	v	typeref:struct:Page_list	file:
page_id	user/testpmap.c	/^int *page_id;$/;"	v
page_init	kern/pmap.c	/^page_init(void)$/;"	f
page_initpp	kern/pmap.c	/^page_initpp(struct Page *pp)$/;"	f	file:
page_insert	kern/pmap.c	/^page_insert(pde_t *pgdir, struct Page *pp, void *va, int perm) $/;"	f
page_lookup	kern/pmap.c	/^page_lookup(pde_t *pgdir, void *va, pte_t **pte_store)$/;"	f
page_remove	kern/pmap.c	/^page_remove(pde_t *pgdir, void *va)$/;"	f
pageref	lib/pageref.c	/^pageref(void *v)$/;"	f
pages	kern/pmap.c	/^struct Page* pages;		\/\/ Virtual address of physical page array$/;"	v	typeref:struct:Page
panic	inc/assert.h	12;"	d
panicstr	kern/init.c	/^static const char *panicstr;$/;"	v	file:
pd_base	inc/mmu.h	/^	uint32_t pd_base;		\/\/ Base address$/;"	m	struct:Pseudodesc
pd_lim	inc/mmu.h	/^	uint16_t pd_lim;		\/\/ Limit$/;"	m	struct:Pseudodesc
pde_t	inc/memlayout.h	/^typedef uint32_t pde_t;$/;"	t
pgdir_walk	kern/pmap.c	/^pgdir_walk(pde_t *pgdir, const void *va, int create)$/;"	f
pgfault	lib/fork.c	/^pgfault(struct UTrapframe *utf)$/;"	f	file:
physaddr_t	fs/fsformat.c	/^typedef uint32_t physaddr_t;$/;"	t	file:
physaddr_t	inc/types.h	/^typedef uint32_t physaddr_t;$/;"	t
pic_init	kern/picirq.c	/^pic_init(void)$/;"	f
pp_link	inc/memlayout.h	/^	Page_LIST_entry_t pp_link;	\/* free list link *\/$/;"	m	struct:Page
pp_ref	inc/memlayout.h	/^	uint16_t pp_ref;$/;"	m	struct:Page
ppn_t	inc/types.h	/^typedef uint32_t ppn_t;$/;"	t
primeproc	user/primes.c	/^primeproc(void)$/;"	f
primeproc	user/primespipe.c	/^primeproc(int fd)$/;"	f
print_expected_mark	user/testpmap.c	/^print_expected_mark(int i) {$/;"	f
print_marked_page	user/testpmap.c	/^print_marked_page(int* pg) {$/;"	f
print_regs	kern/trap.c	/^print_regs(struct PushRegs *regs)$/;"	f
print_trapframe	kern/trap.c	/^print_trapframe(struct Trapframe *tf)$/;"	f
printbuf	lib/fprintf.c	/^struct printbuf {$/;"	s	file:
printbuf	lib/printf.c	/^struct printbuf {$/;"	s	file:
printf	lib/fprintf.c	/^printf(const char *fmt, ...)$/;"	f
printfmt	lib/printfmt.c	/^printfmt(void (*putch)(int, void*), void *putdat, const char *fmt, ...)$/;"	f
printnum	lib/printfmt.c	/^printnum(void (*putch)(int, void*), void *putdat,$/;"	f	file:
protcseg	boot/boot.S	/^protcseg:$/;"	l
pte_t	inc/memlayout.h	/^typedef uint32_t pte_t;$/;"	t
putblk	fs/fsformat.c	/^putblk(struct Block *b)$/;"	f
putch	kern/printf.c	/^putch(int ch, int *cnt)$/;"	f	file:
putch	lib/fprintf.c	/^putch(int ch, void *thunk)$/;"	f	file:
putch	lib/printf.c	/^putch(int ch, struct printbuf *b)$/;"	f	file:
quicktest	grade.sh	/^quicktest () {$/;"	f
r	user/testpmap.c	/^int n, va, r, initva, maxpa, maxva, maxnum, failures;$/;"	v
rcr0	inc/x86.h	/^rcr0(void)$/;"	f
rcr2	inc/x86.h	/^rcr2(void)$/;"	f
rcr3	inc/x86.h	/^rcr3(void)$/;"	f
rcr4	inc/x86.h	/^rcr4(void)$/;"	f
read	lib/fd.c	/^read(int fdnum, void *buf, size_t n)$/;"	f
read_bitmap	fs/fs.c	/^read_bitmap(void)$/;"	f
read_block	fs/fs.c	/^read_block(uint32_t blockno, char **blk)$/;"	f	file:
read_ebp	inc/x86.h	/^read_ebp(void)$/;"	f
read_eflags	inc/x86.h	/^read_eflags(void)$/;"	f
read_eip	kern/monitor.c	/^read_eip()$/;"	f
read_esp	inc/x86.h	/^read_esp(void)$/;"	f
read_map	lib/file.c	/^read_map(int fdnum, off_t offset, void **blk)$/;"	f
read_super	fs/fs.c	/^read_super(void)$/;"	f
read_tsc	inc/x86.h	/^read_tsc(void)$/;"	f
readdeps	mergedep.pl	/^sub readdeps {$/;"	s
readline	lib/readline.c	/^readline(const char *prompt)$/;"	f
readn	fs/fsformat.c	/^readn(int f, void *av, size_t n)$/;"	f
readn	lib/fd.c	/^readn(int fdnum, void *buf, size_t n)$/;"	f
readsect	boot/main.c	/^readsect(void *dst, uint32_t offset)$/;"	f
readseg	boot/main.c	/^readseg(uint32_t va, uint32_t count, uint32_t offset)$/;"	f
reg_eax	inc/trap.h	/^	uint32_t reg_eax;$/;"	m	struct:PushRegs
reg_ebp	inc/trap.h	/^	uint32_t reg_ebp;$/;"	m	struct:PushRegs
reg_ebx	inc/trap.h	/^	uint32_t reg_ebx;$/;"	m	struct:PushRegs
reg_ecx	inc/trap.h	/^	uint32_t reg_ecx;$/;"	m	struct:PushRegs
reg_edi	inc/trap.h	/^	uint32_t reg_edi;$/;"	m	struct:PushRegs
reg_edx	inc/trap.h	/^	uint32_t reg_edx;$/;"	m	struct:PushRegs
reg_esi	inc/trap.h	/^	uint32_t reg_esi;$/;"	m	struct:PushRegs
reg_oesp	inc/trap.h	/^	uint32_t reg_oesp;		\/* Useless *\/$/;"	m	struct:PushRegs
relocated	kern/entry.S	/^relocated:$/;"	l
remove	lib/file.c	/^remove(const char *path)$/;"	f
req_fileid	inc/fs.h	/^	int req_fileid;$/;"	m	struct:Fsreq_close
req_fileid	inc/fs.h	/^	int req_fileid;$/;"	m	struct:Fsreq_dirty
req_fileid	inc/fs.h	/^	int req_fileid;$/;"	m	struct:Fsreq_map
req_fileid	inc/fs.h	/^	int req_fileid;$/;"	m	struct:Fsreq_set_size
req_offset	inc/fs.h	/^	off_t req_offset;$/;"	m	struct:Fsreq_dirty
req_offset	inc/fs.h	/^	off_t req_offset;$/;"	m	struct:Fsreq_map
req_omode	inc/fs.h	/^	int req_omode;$/;"	m	struct:Fsreq_open
req_path	inc/fs.h	/^	char req_path[MAXPATHLEN];$/;"	m	struct:Fsreq_open
req_path	inc/fs.h	/^	char req_path[MAXPATHLEN];$/;"	m	struct:Fsreq_remove
req_size	inc/fs.h	/^	off_t req_size;$/;"	m	struct:Fsreq_set_size
resetfs	grade.sh	/^resetfs() {$/;"	f
result	lib/fprintf.c	/^	ssize_t result;	\/\/ accumulated results from write$/;"	m	struct:printbuf	file:
rpos	kern/console.c	/^	uint32_t rpos;$/;"	m	struct:__anon1	file:
runbochs	grade.sh	/^runbochs () {$/;"	f
runcmd	kern/monitor.c	/^runcmd(char *buf, struct Trapframe *tf)$/;"	f	file:
runtest	grade.sh	/^runtest () {$/;"	f
runtest1	grade.sh	/^runtest1 () {$/;"	f
s_magic	inc/fs.h	/^	uint32_t s_magic;		\/\/ Magic number: FS_MAGIC$/;"	m	struct:Super
s_nblocks	inc/fs.h	/^	uint32_t s_nblocks;		\/\/ Total number of blocks on disk$/;"	m	struct:Super
s_root	inc/fs.h	/^	struct File s_root;		\/\/ Root directory node$/;"	m	struct:Super	typeref:struct:Super::File
sched_yield	kern/sched.c	/^sched_yield(void)$/;"	f
sd_avl	inc/mmu.h	/^	unsigned sd_avl : 1;        \/\/ Unused (available for software use)$/;"	m	struct:Segdesc
sd_base_15_0	inc/mmu.h	/^	unsigned sd_base_15_0 : 16; \/\/ Low bits of segment base address$/;"	m	struct:Segdesc
sd_base_23_16	inc/mmu.h	/^	unsigned sd_base_23_16 : 8; \/\/ Middle bits of segment base address$/;"	m	struct:Segdesc
sd_base_31_24	inc/mmu.h	/^	unsigned sd_base_31_24 : 8; \/\/ High bits of segment base address$/;"	m	struct:Segdesc
sd_db	inc/mmu.h	/^	unsigned sd_db : 1;         \/\/ 0 = 16-bit segment, 1 = 32-bit segment$/;"	m	struct:Segdesc
sd_dpl	inc/mmu.h	/^	unsigned sd_dpl : 2;        \/\/ Descriptor Privilege Level$/;"	m	struct:Segdesc
sd_g	inc/mmu.h	/^	unsigned sd_g : 1;          \/\/ Granularity: limit scaled by 4K when set$/;"	m	struct:Segdesc
sd_lim_15_0	inc/mmu.h	/^	unsigned sd_lim_15_0 : 16;  \/\/ Low bits of segment limit$/;"	m	struct:Segdesc
sd_lim_19_16	inc/mmu.h	/^	unsigned sd_lim_19_16 : 4;  \/\/ High bits of segment limit$/;"	m	struct:Segdesc
sd_p	inc/mmu.h	/^	unsigned sd_p : 1;          \/\/ Present$/;"	m	struct:Segdesc
sd_rsv1	inc/mmu.h	/^	unsigned sd_rsv1 : 1;       \/\/ Reserved$/;"	m	struct:Segdesc
sd_s	inc/mmu.h	/^	unsigned sd_s : 1;          \/\/ 0 = system, 1 = application$/;"	m	struct:Segdesc
sd_type	inc/mmu.h	/^	unsigned sd_type : 4;       \/\/ Segment type (see STS_ constants)$/;"	m	struct:Segdesc
seek	lib/fd.c	/^seek(int fdnum, off_t offset)$/;"	f
segment_alloc	kern/env.c	/^segment_alloc(struct Env *e, void *va, size_t len)$/;"	f	file:
sequence	user/testpmap.c	/^int sequence[] = { 0,  1,   1,   2,   3, $/;"	v
sequence_length	user/testpmap.c	/^int sequence_length = 16;$/;"	v
serial_exists	kern/console.c	/^static bool serial_exists;$/;"	v	file:
serial_init	kern/console.c	/^serial_init(void)$/;"	f
serial_intr	kern/console.c	/^serial_intr(void)$/;"	f
serial_proc_data	kern/console.c	/^serial_proc_data(void)$/;"	f
serve	fs/serv.c	/^serve(void)$/;"	f
serve_close	fs/serv.c	/^serve_close(envid_t envid, struct Fsreq_close *rq)$/;"	f
serve_dirty	fs/serv.c	/^serve_dirty(envid_t envid, struct Fsreq_dirty *rq)$/;"	f
serve_init	fs/serv.c	/^serve_init(void)$/;"	f
serve_map	fs/serv.c	/^serve_map(envid_t envid, struct Fsreq_map *rq)$/;"	f
serve_open	fs/serv.c	/^serve_open(envid_t envid, struct Fsreq_open *rq)$/;"	f
serve_remove	fs/serv.c	/^serve_remove(envid_t envid, struct Fsreq_remove *rq)$/;"	f
serve_set_size	fs/serv.c	/^serve_set_size(envid_t envid, struct Fsreq_set_size *rq)$/;"	f
serve_sync	fs/serv.c	/^serve_sync(envid_t envid)$/;"	f
set_pgfault_handler	lib/pgfault.c	/^set_pgfault_handler(void (*handler)(struct UTrapframe *utf))$/;"	f
sfork	lib/fork.c	/^sfork(void)$/;"	f
sh_addr	inc/elf.h	/^	uint32_t sh_addr;$/;"	m	struct:Secthdr
sh_addralign	inc/elf.h	/^	uint32_t sh_addralign;$/;"	m	struct:Secthdr
sh_entsize	inc/elf.h	/^	uint32_t sh_entsize;$/;"	m	struct:Secthdr
sh_flags	inc/elf.h	/^	uint32_t sh_flags;$/;"	m	struct:Secthdr
sh_info	inc/elf.h	/^	uint32_t sh_info;$/;"	m	struct:Secthdr
sh_link	inc/elf.h	/^	uint32_t sh_link;$/;"	m	struct:Secthdr
sh_name	inc/elf.h	/^	uint32_t sh_name;$/;"	m	struct:Secthdr
sh_offset	inc/elf.h	/^	uint32_t sh_offset;$/;"	m	struct:Secthdr
sh_size	inc/elf.h	/^	uint32_t sh_size;$/;"	m	struct:Secthdr
sh_type	inc/elf.h	/^	uint32_t sh_type;$/;"	m	struct:Secthdr
shiftcode	kern/console.c	/^static uint8_t shiftcode[256] = $/;"	v	file:
shiftmap	kern/console.c	/^static uint8_t shiftmap[256] = $/;"	v	file:
size_t	inc/types.h	/^typedef uint32_t size_t;$/;"	t
skip_slash	fs/fs.c	/^skip_slash(const char *p)$/;"	f	file:
snprintf	lib/printfmt.c	/^snprintf(char *buf, int n, const char *fmt, ...)$/;"	f
spawn	lib/spawn.c	/^spawn(const char *prog, const char **argv)$/;"	f
spawnl	lib/spawn.c	/^spawnl(const char *prog, const char *arg0, ...)$/;"	f
spin	boot/boot.S	/^spin:$/;"	l
spin	kern/entry.S	/^spin:	jmp	spin$/;"	l
sprintbuf	lib/printfmt.c	/^struct sprintbuf {$/;"	s	file:
sprintputch	lib/printfmt.c	/^sprintputch(int ch, struct sprintbuf *b)$/;"	f	file:
ssize_t	inc/types.h	/^typedef int32_t ssize_t;$/;"	t
st_dev	inc/fd.h	/^	struct Dev *st_dev;$/;"	m	struct:Stat	typeref:struct:Stat::Dev
st_isdir	inc/fd.h	/^	int st_isdir;$/;"	m	struct:Stat
st_name	inc/fd.h	/^	char st_name[MAXNAMELEN];$/;"	m	struct:Stat
st_size	inc/fd.h	/^	off_t st_size;$/;"	m	struct:Stat
stab_binsearch	kern/kdebug.c	/^stab_binsearch(const struct Stab *stabs, int *region_left, int *region_right,$/;"	f	file:
stab_end	kern/kdebug.c	/^	const struct Stab *stab_end;$/;"	m	struct:UserStabData	typeref:struct:UserStabData::Stab	file:
stabs	kern/kdebug.c	/^	const struct Stab *stabs;$/;"	m	struct:UserStabData	typeref:struct:UserStabData::Stab	file:
stabstr	kern/kdebug.c	/^	const char *stabstr;$/;"	m	struct:UserStabData	file:
stabstr_end	kern/kdebug.c	/^	const char *stabstr_end;$/;"	m	struct:UserStabData	file:
start	boot/boot.S	/^start:$/;"	l
stat	lib/fd.c	/^stat(const char *path, struct Stat *stat)$/;"	f
static_assert	inc/assert.h	18;"	d
storeblk	fs/fsformat.c	/^storeblk(struct File *f, struct Block *b, int nblk)$/;"	f
strchr	lib/string.c	/^strchr(const char *s, char c)$/;"	f
strcmp	lib/string.c	/^strcmp(const char *p, const char *q)$/;"	f
strcpy	lib/string.c	/^strcpy(char *dst, const char *src)$/;"	f
strecmp	fs/test.c	/^strecmp(char *a, char *b)$/;"	f
strecmp	user/testfsipc.c	/^strecmp(const char *a, const char *b)$/;"	f
strfind	lib/string.c	/^strfind(const char *s, char c)$/;"	f
strlcpy	lib/string.c	/^strlcpy(char *dst, const char *src, size_t size)$/;"	f
strlen	lib/string.c	/^strlen(const char *s)$/;"	f
strncmp	lib/string.c	/^strncmp(const char *p, const char *q, size_t n)$/;"	f
strncpy	lib/string.c	/^strncpy(char *dst, const char *src, size_t size) {$/;"	f
strnlen	lib/string.c	/^strnlen(const char *s, size_t size)$/;"	f
strtol	lib/string.c	/^strtol(const char *s, char **endptr, int base)$/;"	f
stubtest	grade.sh	/^stubtest () {$/;"	f
sum	user/init.c	/^sum(const char *s, int n)$/;"	f
super	fs/fs.c	/^struct Super *super;		\/\/ superblock$/;"	v	typeref:struct:Super
super	fs/fsformat.c	/^struct Super super;$/;"	v	typeref:struct:Super
swizzle	fs/fsformat.c	/^swizzle(uint32_t *x)$/;"	f
swizzleblock	fs/fsformat.c	/^swizzleblock(struct Block *b)$/;"	f
swizzlefile	fs/fsformat.c	/^swizzlefile(struct File *f)$/;"	f
sync	lib/file.c	/^sync(void)$/;"	f
sys_cgetc	kern/syscall.c	/^sys_cgetc(void)$/;"	f	file:
sys_cgetc	lib/syscall.c	/^sys_cgetc(void)$/;"	f
sys_cputs	kern/syscall.c	/^sys_cputs(const char *s, size_t len)$/;"	f	file:
sys_cputs	lib/syscall.c	/^sys_cputs(const char *s, size_t len)$/;"	f
sys_env_destroy	kern/syscall.c	/^sys_env_destroy(envid_t envid)$/;"	f	file:
sys_env_destroy	lib/syscall.c	/^sys_env_destroy(envid_t envid)$/;"	f
sys_env_set_pgfault_upcall	kern/syscall.c	/^sys_env_set_pgfault_upcall(envid_t envid, void *func)$/;"	f	file:
sys_env_set_pgfault_upcall	lib/syscall.c	/^sys_env_set_pgfault_upcall(envid_t envid, void *upcall)$/;"	f
sys_env_set_status	kern/syscall.c	/^sys_env_set_status(envid_t envid, int status)$/;"	f	file:
sys_env_set_status	lib/syscall.c	/^sys_env_set_status(envid_t envid, int status)$/;"	f
sys_env_set_trapframe	kern/syscall.c	/^sys_env_set_trapframe(envid_t envid, struct Trapframe *tf)$/;"	f	file:
sys_env_set_trapframe	lib/syscall.c	/^sys_env_set_trapframe(envid_t envid, struct Trapframe *tf)$/;"	f
sys_exofork	inc/lib.h	/^sys_exofork(void)$/;"	f
sys_exofork	kern/syscall.c	/^sys_exofork(void)$/;"	f	file:
sys_getenvid	kern/syscall.c	/^sys_getenvid(void)$/;"	f	file:
sys_getenvid	lib/syscall.c	/^sys_getenvid(void)$/;"	f
sys_ipc_recv	kern/syscall.c	/^sys_ipc_recv(void *dstva)$/;"	f	file:
sys_ipc_recv	lib/syscall.c	/^sys_ipc_recv(void *dstva)$/;"	f
sys_ipc_try_send	kern/syscall.c	/^sys_ipc_try_send(envid_t envid, uint32_t value, void *srcva, unsigned perm)$/;"	f	file:
sys_ipc_try_send	lib/syscall.c	/^sys_ipc_try_send(envid_t envid, uint32_t value, void *srcva, int perm)$/;"	f
sys_page_alloc	kern/syscall.c	/^sys_page_alloc(envid_t envid, void *va, int perm)$/;"	f	file:
sys_page_alloc	lib/syscall.c	/^sys_page_alloc(envid_t envid, void *va, int perm)$/;"	f
sys_page_map	kern/syscall.c	/^sys_page_map(envid_t srcenvid, void *srcva,$/;"	f	file:
sys_page_map	lib/syscall.c	/^sys_page_map(envid_t srcenv, void *srcva, envid_t dstenv, void *dstva, int perm)$/;"	f
sys_page_unmap	kern/syscall.c	/^sys_page_unmap(envid_t envid, void *va)$/;"	f	file:
sys_page_unmap	lib/syscall.c	/^sys_page_unmap(envid_t envid, void *va)$/;"	f
sys_yield	kern/syscall.c	/^sys_yield(void)$/;"	f	file:
sys_yield	lib/syscall.c	/^sys_yield(void)$/;"	f
syscall	kern/syscall.c	/^syscall(uint32_t syscallno, uint32_t a1, uint32_t a2, uint32_t a3, uint32_t a4, uint32_t a5)$/;"	f
syscall	lib/syscall.c	/^syscall(int num, int check, uint32_t a1, uint32_t a2, uint32_t a3, uint32_t a4, uint32_t a5)$/;"	f	file:
test_page	user/testpmap.c	/^test_page(int* pg, int i) {$/;"	f
test_range	user/testpmap.c	/^test_range(int startva, int endva, int startn) {$/;"	f
tf_cs	inc/trap.h	/^	uint16_t tf_cs;$/;"	m	struct:Trapframe
tf_ds	inc/trap.h	/^	uint16_t tf_ds;$/;"	m	struct:Trapframe
tf_eflags	inc/trap.h	/^	uint32_t tf_eflags;$/;"	m	struct:Trapframe
tf_eip	inc/trap.h	/^	uintptr_t tf_eip;$/;"	m	struct:Trapframe
tf_err	inc/trap.h	/^	uint32_t tf_err;$/;"	m	struct:Trapframe
tf_es	inc/trap.h	/^	uint16_t tf_es;$/;"	m	struct:Trapframe
tf_esp	inc/trap.h	/^	uintptr_t tf_esp;$/;"	m	struct:Trapframe
tf_padding1	inc/trap.h	/^	uint16_t tf_padding1;$/;"	m	struct:Trapframe
tf_padding2	inc/trap.h	/^	uint16_t tf_padding2;$/;"	m	struct:Trapframe
tf_padding3	inc/trap.h	/^	uint16_t tf_padding3;$/;"	m	struct:Trapframe
tf_padding4	inc/trap.h	/^	uint16_t tf_padding4;$/;"	m	struct:Trapframe
tf_regs	inc/trap.h	/^	struct PushRegs tf_regs;$/;"	m	struct:Trapframe	typeref:struct:Trapframe::PushRegs
tf_ss	inc/trap.h	/^	uint16_t tf_ss;$/;"	m	struct:Trapframe
tf_trapno	inc/trap.h	/^	uint32_t tf_trapno;$/;"	m	struct:Trapframe
tlb_invalidate	kern/pmap.c	/^tlb_invalidate(pde_t *pgdir, void *va)$/;"	f
tlbflush	inc/x86.h	/^tlbflush(void)$/;"	f
togglecode	kern/console.c	/^static uint8_t togglecode[256] = $/;"	v	file:
trap	kern/trap.c	/^trap(struct Trapframe *tf)$/;"	f
trap_dispatch	kern/trap.c	/^trap_dispatch(struct Trapframe *tf)$/;"	f	file:
trapname	kern/trap.c	/^static const char *trapname(int trapno)$/;"	f	file:
ts	kern/trap.c	/^static struct Taskstate ts;$/;"	v	typeref:struct:Taskstate	file:
ts_cr3	inc/mmu.h	/^	physaddr_t ts_cr3;	\/\/ Page directory base$/;"	m	struct:Taskstate
ts_cs	inc/mmu.h	/^	uint16_t ts_cs;$/;"	m	struct:Taskstate
ts_ds	inc/mmu.h	/^	uint16_t ts_ds;$/;"	m	struct:Taskstate
ts_eax	inc/mmu.h	/^	uint32_t ts_eax;	\/\/ More saved state (registers)$/;"	m	struct:Taskstate
ts_ebp	inc/mmu.h	/^	uintptr_t ts_ebp;$/;"	m	struct:Taskstate
ts_ebx	inc/mmu.h	/^	uint32_t ts_ebx;$/;"	m	struct:Taskstate
ts_ecx	inc/mmu.h	/^	uint32_t ts_ecx;$/;"	m	struct:Taskstate
ts_edi	inc/mmu.h	/^	uint32_t ts_edi;$/;"	m	struct:Taskstate
ts_edx	inc/mmu.h	/^	uint32_t ts_edx;$/;"	m	struct:Taskstate
ts_eflags	inc/mmu.h	/^	uint32_t ts_eflags;$/;"	m	struct:Taskstate
ts_eip	inc/mmu.h	/^	uintptr_t ts_eip;	\/\/ Saved state from last task switch$/;"	m	struct:Taskstate
ts_es	inc/mmu.h	/^	uint16_t ts_es;		\/\/ Even more saved state (segment selectors)$/;"	m	struct:Taskstate
ts_esi	inc/mmu.h	/^	uint32_t ts_esi;$/;"	m	struct:Taskstate
ts_esp	inc/mmu.h	/^	uintptr_t ts_esp;$/;"	m	struct:Taskstate
ts_esp0	inc/mmu.h	/^	uintptr_t ts_esp0;	\/\/ Stack pointers and segment selectors$/;"	m	struct:Taskstate
ts_esp1	inc/mmu.h	/^	uintptr_t ts_esp1;$/;"	m	struct:Taskstate
ts_esp2	inc/mmu.h	/^	uintptr_t ts_esp2;$/;"	m	struct:Taskstate
ts_fs	inc/mmu.h	/^	uint16_t ts_fs;$/;"	m	struct:Taskstate
ts_gs	inc/mmu.h	/^	uint16_t ts_gs;$/;"	m	struct:Taskstate
ts_iomb	inc/mmu.h	/^	uint16_t ts_iomb;	\/\/ I\/O map base address$/;"	m	struct:Taskstate
ts_ldt	inc/mmu.h	/^	uint16_t ts_ldt;$/;"	m	struct:Taskstate
ts_link	inc/mmu.h	/^	uint32_t ts_link;	\/\/ Old ts selector$/;"	m	struct:Taskstate
ts_padding1	inc/mmu.h	/^	uint16_t ts_padding1;$/;"	m	struct:Taskstate
ts_padding10	inc/mmu.h	/^	uint16_t ts_padding10;$/;"	m	struct:Taskstate
ts_padding2	inc/mmu.h	/^	uint16_t ts_padding2;$/;"	m	struct:Taskstate
ts_padding3	inc/mmu.h	/^	uint16_t ts_padding3;$/;"	m	struct:Taskstate
ts_padding4	inc/mmu.h	/^	uint16_t ts_padding4;$/;"	m	struct:Taskstate
ts_padding5	inc/mmu.h	/^	uint16_t ts_padding5;$/;"	m	struct:Taskstate
ts_padding6	inc/mmu.h	/^	uint16_t ts_padding6;$/;"	m	struct:Taskstate
ts_padding7	inc/mmu.h	/^	uint16_t ts_padding7;$/;"	m	struct:Taskstate
ts_padding8	inc/mmu.h	/^	uint16_t ts_padding8;$/;"	m	struct:Taskstate
ts_padding9	inc/mmu.h	/^	uint16_t ts_padding9;$/;"	m	struct:Taskstate
ts_ss	inc/mmu.h	/^	uint16_t ts_ss;$/;"	m	struct:Taskstate
ts_ss0	inc/mmu.h	/^	uint16_t ts_ss0;	\/\/   after an increase in privilege level$/;"	m	struct:Taskstate
ts_ss1	inc/mmu.h	/^	uint16_t ts_ss1;$/;"	m	struct:Taskstate
ts_ss2	inc/mmu.h	/^	uint16_t ts_ss2;$/;"	m	struct:Taskstate
ts_t	inc/mmu.h	/^	uint16_t ts_t;		\/\/ Trap on task switch$/;"	m	struct:Taskstate
type	fs/fsformat.c	/^	uint32_t type;$/;"	m	struct:Block	file:
uint16_t	inc/types.h	/^typedef unsigned short uint16_t;$/;"	t
uint32_t	inc/types.h	/^typedef unsigned int uint32_t;$/;"	t
uint64_t	inc/types.h	/^typedef unsigned long long uint64_t;$/;"	t
uint8_t	inc/types.h	/^typedef unsigned char uint8_t;$/;"	t
uintptr_t	inc/types.h	/^typedef uint32_t uintptr_t;$/;"	t
umain	fs/serv.c	/^umain(void)$/;"	f
umain	user/cat.c	/^umain(int argc, char **argv)$/;"	f
umain	user/echo.c	/^umain(int argc, char **argv)$/;"	f
umain	user/faultwrite.c	/^umain(void)$/;"	f
umain	user/forktree.c	/^umain(void)$/;"	f
umain	user/hello.c	/^umain(void)$/;"	f
umain	user/icode.c	/^umain(void)$/;"	f
umain	user/idle.c	/^umain(void)$/;"	f
umain	user/init.c	/^umain(int argc, char **argv)$/;"	f
umain	user/initsh.c	/^umain(int argc, char **argv)$/;"	f
umain	user/ls.c	/^umain(int argc, char **argv)$/;"	f
umain	user/lsfd.c	/^umain(int argc, char **argv)$/;"	f
umain	user/num.c	/^umain(int argc, char **argv)$/;"	f
umain	user/pingpong.c	/^umain(void)$/;"	f
umain	user/primes.c	/^umain(void)$/;"	f
umain	user/primespipe.c	/^umain(void)$/;"	f
umain	user/spawnhello.c	/^umain(void)$/;"	f
umain	user/spawninit.c	/^umain(void)$/;"	f
umain	user/testfsipc.c	/^umain(void)$/;"	f
umain	user/testpmap.c	/^umain(int argc, char **argv)$/;"	f
umain	user/writemotd.c	/^umain(void)$/;"	f
unmap_block	fs/fs.c	/^unmap_block(uint32_t blockno)$/;"	f
unmap_range	user/testpmap.c	/^unmap_range(int startva, int endva) {$/;"	f
usage	fs/fsformat.c	/^usage(void)$/;"	f
usage	user/ls.c	/^usage(void)$/;"	f
usage	user/lsfd.c	/^usage(void)$/;"	f
used	fs/fsformat.c	/^	uint32_t used;$/;"	m	struct:Block	file:
user_mem_assert	kern/pmap.c	/^user_mem_assert(struct Env *env, const void *va, size_t len, int perm)$/;"	f
user_mem_check	kern/pmap.c	/^user_mem_check(struct Env *env, const void *va, size_t len, int perm)$/;"	f
user_mem_check_addr	kern/pmap.c	/^static uintptr_t user_mem_check_addr;$/;"	v	file:
utf_eflags	inc/trap.h	/^	uint32_t utf_eflags;$/;"	m	struct:UTrapframe
utf_eip	inc/trap.h	/^	uintptr_t utf_eip;$/;"	m	struct:UTrapframe
utf_err	inc/trap.h	/^	uint32_t utf_err;$/;"	m	struct:UTrapframe
utf_esp	inc/trap.h	/^	uintptr_t utf_esp;$/;"	m	struct:UTrapframe
utf_fault_va	inc/trap.h	/^	uint32_t utf_fault_va;	\/* va for T_PGFLT, 0 otherwise *\/$/;"	m	struct:UTrapframe
utf_regs	inc/trap.h	/^	struct PushRegs utf_regs;$/;"	m	struct:UTrapframe	typeref:struct:UTrapframe::PushRegs
va	user/testpmap.c	/^int n, va, r, initva, maxpa, maxva, maxnum, failures;$/;"	v
va_arg	inc/stdarg.h	14;"	d
va_end	inc/stdarg.h	17;"	d
va_is_dirty	fs/fs.c	/^va_is_dirty(void *va)$/;"	f
va_is_mapped	fs/fs.c	/^va_is_mapped(void *va)$/;"	f
va_list	inc/stdarg.h	/^typedef char *va_list;$/;"	t
va_start	inc/stdarg.h	11;"	d
vcprintf	kern/printf.c	/^vcprintf(const char *fmt, va_list ap)$/;"	f
vcprintf	lib/printf.c	/^vcprintf(const char *fmt, va_list ap)$/;"	f
vfprintf	lib/fprintf.c	/^vfprintf(int fd, const char *fmt, va_list ap)$/;"	f
vprintfmt	lib/printfmt.c	/^vprintfmt(void (*putch)(int, void*), void *putdat, const char *fmt, va_list ap)$/;"	f
vsnprintf	lib/printfmt.c	/^vsnprintf(char *buf, int n, const char *fmt, va_list ap)$/;"	f
waitdisk	boot/main.c	/^waitdisk(void)$/;"	f
walk_path	fs/fs.c	/^walk_path(const char *path, struct File **pdir, struct File **pf, char *lastelem)$/;"	f	file:
warn	inc/assert.h	11;"	d
wpos	kern/console.c	/^	uint32_t wpos;$/;"	m	struct:__anon1	file:
write	lib/fd.c	/^write(int fdnum, const void *buf, size_t n)$/;"	f
write_block	fs/fs.c	/^write_block(uint32_t blockno)$/;"	f
write_eflags	inc/x86.h	/^write_eflags(uint32_t eflags)$/;"	f
writebuf	lib/fprintf.c	/^writebuf(struct printbuf *b)$/;"	f	file:
writedirectory	fs/fsformat.c	/^writedirectory(struct File *parentdirf, char *name, int root)$/;"	f
writefile	fs/fsformat.c	/^writefile(struct File *dirf, const char *name)$/;"	f
